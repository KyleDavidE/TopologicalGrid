{"version":3,"sources":["webpack:///webpack/bootstrap e07bf2f3cbf191b4357f","webpack:///./src/opts.ts","webpack:///./src/Side.ts","webpack:///./src/DirMtx.ts","webpack:///./src/Cursor.ts","webpack:///./src/Tile.ts","webpack:///./src/ColorTile.ts","webpack:///./src/compose.ts","webpack:///./src/RenderableEntity.ts","webpack:///./src/index.ts","webpack:///./src/App.ts","webpack:///./src/Renderer.ts","webpack:///./src/Projector.ts","webpack:///./src/LinearObjectPool.ts","webpack:///./src/testLevels.ts","webpack:///./src/TileGrid.ts","webpack:///./src/SideReference.ts","webpack:///./src/TileView.ts","webpack:///./src/tickTackToe/TickTackToeTile.ts","webpack:///./src/Player.ts","webpack:///./src/Entity.ts","webpack:///./src/ViewCursor.ts","webpack:///./src/Bolt.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","side","deltas","Array","from","length","map","_","delta","y","x","makeDelta","reverseSide","base","args","reduce","dirMtxProductImpl","mtx","dir","det","dirMtxApply","vec","left","right","primary","secondary","window","debug","console","log","__WEBPACK_IMPORTED_MODULE_0__Side__","Cursor","[object Object]","this","mag","dx","dy","nextId","links","id","entities","Set","tileViews","__WEBPACK_IMPORTED_MODULE_2__TileView__","reciprocate","link","to","unlink","destSide","fromSide","toTile","toSide","__WEBPACK_IMPORTED_MODULE_1__Side__","reflect","addReverse","__WEBPACK_IMPORTED_MODULE_0__SideReference__","fromOpts","ctx","t","loadTimer","entity","add","__WEBPACK_IMPORTED_MODULE_0__Tile__","color","super","stepTime","noiseLevel","Math","random","render","globalAlpha","pow","fillStyle","fillRect","__WEBPACK_IMPORTED_MODULE_1__opts__","strokeStyle","fns","leftFn","rightFn","__WEBPACK_IMPORTED_MODULE_0__Entity__","width","height","baseTile","gone","trackingTiles","register","out","move","tile","respawn","trackWidth","view","track","renderer","renderHistory","rh","tracker","renderKey","orientation","pt","onEntityX","onEntityY","has","save","applyOrientation","__WEBPACK_IMPORTED_MODULE_1__DirMtx__","translate","__WEBPACK_IMPORTED_MODULE_2__opts__","restore","app","level","__WEBPACK_IMPORTED_MODULE_1__testLevels__","movementKeys","w","a","shootKeys","k","j","PLAYER_SPEED","stepables","vel","__WEBPACK_IMPORTED_MODULE_2__Cursor__","monitorKeys","interactLock","can","document","getElementById","__WEBPACK_IMPORTED_MODULE_0__Renderer__","requestAnimationFrame","nt","tick","onkeydown","e","keyDown","onkeyup","keyUp","ondblclick","requestPointerLock","allEvt","onmousemove","pointerLockElement","abs","movementX","movementY","player","__WEBPACK_IMPORTED_MODULE_4__opts__","__WEBPACK_IMPORTED_MODULE_3__Player__","getView","getNeighbor","cam","center","clone","dt","wat","innerWidth","innerHeight","tryMove","stepable","step","delete","ctr","locCam","copy","stepOn","watNumber","key","interact","performance","now","shoot","shiftKey","maxSquareSquare","z","max","DEBUG","SUPERDebug","TARGET_SIZE","projector","__WEBPACK_IMPORTED_MODULE_0__Projector__","getContext","root","offsetX","offsetY","displayOffsetX","displayOffsetY","scale","items","project","item","beginPath","rect","clip","moveTo","cos","minTheta","sin","lineTo","maxTheta","stroke","r","sqrt","isRoot","anglesLength","fromAng","angles","toAng","sf","lineWidth","fillText","entitiesInit","isOnTile","renderInContext","doTranslate","rotate","PI","reduceAngle","angle","b","reduceAngleCentered","FUDGE_THETA","ANGLE_RANGE","ProjectionPath","Float64Array","centerAngle","atan2","Infinity","ox","oy","theta","addRangeImpl","startIndex","endIndex","startIsOutside","endIsOutside","lengthChange","copyWithin","EDGE_GLITCH_REDUCTION_DIST","lookup","Map","projectionPathPool","__WEBPACK_IMPORTED_MODULE_0__LinearObjectPool__","renderRadiusX","renderRadiusY","displayOffestY","done","que","clear","addRoot","rootPath","pop","init","set","push","shift","considerItem","warn","values","considerSide","axis","offsetZ","nextTile","nextX","nextY","lineZ","topU","bottomU","makeAng","u","projectAng","slopeUZ","tan","colU","newItem","considerAngleRange","newFromAng","newToAng","addRange","foldAngleRange","mid","makeT","size","usedIndex","usedSize","clean","makeHubRoom","grid1","__WEBPACK_IMPORTED_MODULE_0__TileGrid__","solidColorTiles","grid2","portSpace","center1","center2","bridge","reverse","__WEBPACK_IMPORTED_MODULE_1__ColorTile__","getReference","ballPort","grid","dynamicColor","mirror","cardinal","isolate","shortWay","S","fastLane","longGrid","shortLength","rain","shortGrid","targ","fastLane2","colorTile","threeTurns","branches","addSide","inner","north","east","west","floor","branches2","tickTackToeLayer","tickTackToeDonut","tickTackToeKlign","tickTackToeMirror","tickTackToeDonutOffset","mobius","len","ot","nextDir","spiral","xc","yc","next","h","offset","__WEBPACK_IMPORTED_MODULE_2__compose__","__WEBPACK_IMPORTED_MODULE_3__tickTackToe_TickTackToeTile__","W","H","worlds","forEach","reduceRight","rightTile","rightBridge","worldRoot","hubTile","hubBridge","leftBridge","leftTile","layers","getTiles","tiles","row","SideReference","__WEBPACK_IMPORTED_MODULE_0__DirMtx__","WeakMap","TileView","edge","Turn","turnColor","turn","RED","BLACK","TickTackToeGame","won","NONE","blankTiles","MARGIN","singleStepMovement","movement","dirs","movementMethods","TickTackToeTile","__WEBPACK_IMPORTED_MODULE_0__ColorTile__","lengthForWin","occupied","game","isWinningLine","margin","strokeRect","movmentPattern","pair","tallyInDir","drawWinningLine","linkGame","didWin","PLAYER_SIZE","onScreenSize","__WEBPACK_IMPORTED_MODULE_0__RenderableEntity__","spawnPt","lastMovementDir","bolt","__WEBPACK_IMPORTED_MODULE_2__Bolt__","addStepable","trackHeight","RangeError","trackingTilesOld","trackingPointX","trackingPointY","__WEBPACK_IMPORTED_MODULE_0__ViewCursor__","centerOld","xSide","ySide","xLeft","yLeft","xLocked","yLocked","oPosn","dist","distLeft","maxMovement","newDist","movementUpToEdge","moveWithinTile","crossingValid","thisTracker","tryCrossEdge","outer","tgtView","leftView","topView","ViewCursor","__WEBPACK_IMPORTED_MODULE_0__Cursor__","other","fork","canMove","min","BOLT_SPEED","age","dirPt","stayAlive","kill"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e07bf2f3cbf191b4357f","export const TILE_SIZE = 100;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/opts.ts\n// module id = 0\n// module chunks = 0","export const directions = [0 /* right */, 1 /* bottom */, 2 /* left */, 3 /* top */];\r\nfunction makeDelta(i) {\r\n    const delta = i > 1 ? -1 : 1;\r\n    if (i & 1) {\r\n        return { y: delta, x: 0 };\r\n    }\r\n    else {\r\n        return { x: delta, y: 0 };\r\n    }\r\n}\r\nconst deltas = Array.from({ length: 4 }).map((_, i) => makeDelta(i));\r\nexport function getDelta(side) {\r\n    return deltas[side];\r\n}\r\nexport function reverseSide(side) {\r\n    return side ^ 2;\r\n}\r\nexport function getPerpendicularCW(side) {\r\n    return (side + 1) & 3;\r\n}\r\nexport function getPerpendicularCCW(side) {\r\n    return (side + 3) & 3;\r\n}\r\nexport function makePositive(side) {\r\n    return side & 1;\r\n}\r\nexport function getTravel(side) {\r\n    return makePositive(getPerpendicularCW(side));\r\n}\r\nexport function rotate(side, by) {\r\n    return (side + by) & 3;\r\n}\r\nexport function reflect(side, { x, y }) {\r\n    return (side & 1 ? y : x) ? reverseSide(side) : side;\r\n}\r\nexport function invertReflection({ x, y }) {\r\n    return { x: !x, y: !y };\r\n}\r\nexport function mergeReflections({ x, y }, { x: x2, y: y2 }) {\r\n    return {\r\n        x: x !== x2,\r\n        y: y !== y2\r\n    };\r\n}\r\nexport function getOffside(posn) {\r\n    if (posn.x > 1)\r\n        return 0 /* right */;\r\n    if (posn.x < -1)\r\n        return 2 /* left */;\r\n    if (posn.y > 1)\r\n        return 1 /* bottom */;\r\n    if (posn.y < -1)\r\n        return 3 /* top */;\r\n    return -1;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Side.ts\n// module id = 1\n// module chunks = 0","import { getPerpendicularCCW } from './Side';\r\nimport { Cursor } from './Cursor';\r\n// function dirMtxApply(mtx: DirMTX, vec: Side): Side{\r\n//     return (vec & 1 ? ((mtx & 0b11) + ((mtx & 0b100) ? 1 : -1) ) & 0b11 : mtx & 0b11) ^ (vec & 0b10);\r\n// }\r\nexport function dirMtxApply(mtx, vec) {\r\n    return ((mtx & 0b11) + ((mtx & 0b100) ? -vec : vec)) & 0b11;\r\n}\r\nexport function dirMtxProductImpl(left, right) {\r\n    const primary = dirMtxApply(left, dirMtxApply(right, 0));\r\n    const secondary = dirMtxApply(left, dirMtxApply(right, 1));\r\n    if (window.debug)\r\n        console.log(primary, secondary);\r\n    return primary | (getPerpendicularCCW(primary) === secondary ? 0b100 : 0);\r\n}\r\nexport function dirMtxProduct(base, ...args) {\r\n    return args.reduce(dirMtxProductImpl, base);\r\n}\r\nexport function dirMtxInverse(mtx) {\r\n    return (mtx & 0b100) ? mtx : (-mtx) & 0b11;\r\n}\r\nexport function makeDirMtx(dir, det) {\r\n    return det ? (dir & 0b11) | 0b100 : dir & 0b11;\r\n}\r\nexport function dirMtxApplyPt(mtx, pt) {\r\n    return new Cursor({ x: 0, y: 0 }).step(dirMtxApply(mtx, 0 /* right */), pt.x).step(dirMtxApply(mtx, 1 /* bottom */), pt.y);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/DirMtx.ts\n// module id = 2\n// module chunks = 0","import { getDelta } from \"./Side\";\r\nexport class Cursor {\r\n    constructor(p) {\r\n        this.x = p.x;\r\n        this.y = p.y;\r\n    }\r\n    step(side, mag = 1) {\r\n        const { x: dx, y: dy } = getDelta(side);\r\n        this.x += dx * mag;\r\n        this.y += dy * mag;\r\n        return this;\r\n    }\r\n    fork() {\r\n        return new Cursor(this);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Cursor.ts\n// module id = 3\n// module chunks = 0","import { SideReference } from './SideReference';\r\nimport { reverseSide } from './Side';\r\nimport { TileView } from './TileView';\r\nlet nextId = 0;\r\nexport class Tile {\r\n    constructor() {\r\n        this.links = [null, null, null, null];\r\n        this.id = nextId++;\r\n        this.entities = new Set();\r\n        this.tileViews = Array(8);\r\n        for (let i = 0; i < 8; i++) {\r\n            this.tileViews[i] = new TileView(this, i);\r\n        }\r\n    }\r\n    getReference(i) {\r\n        return this.links[i];\r\n    }\r\n    unlink(i, reciprocate = true) {\r\n        if (this.links[i]) {\r\n            const link = this.links[i];\r\n            if (reciprocate) {\r\n                link.to.unlink(link.destSide, false);\r\n            }\r\n            this.links[i] = null;\r\n        }\r\n    }\r\n    link(fromSide, toTile, toSide = reverseSide(fromSide), { reflect = false, addReverse = true } = {}) {\r\n        this.unlink(fromSide);\r\n        this.links[fromSide] = SideReference.fromOpts(toTile, fromSide, toSide, reflect);\r\n        if (addReverse) {\r\n            toTile.link(toSide, this, fromSide, {\r\n                addReverse: false,\r\n                reflect\r\n            });\r\n        }\r\n    }\r\n    getView(mtx) {\r\n        return this.tileViews[mtx];\r\n    }\r\n    render(ctx, t) {\r\n        this.loadTimer = t;\r\n    }\r\n    isolate() {\r\n        for (let i = 0; i < 4; i++) {\r\n            this.unlink(i);\r\n        }\r\n    }\r\n    stepOn(t) {\r\n    }\r\n    interact(t) {\r\n    }\r\n    track(entity) {\r\n        this.entities.add(entity);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Tile.ts\n// module id = 4\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nexport class ColorTile extends Tile {\r\n    constructor(color) {\r\n        super();\r\n        this.stepTime = 0;\r\n        this.color = color;\r\n        this.noiseLevel = 1 - Math.random() * 0.2;\r\n    }\r\n    render(ctx, t) {\r\n        super.render(ctx, t);\r\n        ctx.globalAlpha = (1 - Math.pow(2, (this.stepTime - t) / 1000) / 3) * this.noiseLevel;\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\r\n        ctx.globalAlpha = 1;\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n    stepOn(t) {\r\n        this.stepTime = t;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ColorTile.ts\n// module id = 5\n// module chunks = 0","export function strictCompose(fns) {\r\n    return fns.reduce((leftFn, rightFn) => (x) => leftFn(rightFn(x)), x => x);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/compose.ts\n// module id = 6\n// module chunks = 0","import { Entity } from \"./Entity\";\r\nimport { dirMtxInverse } from \"./DirMtx\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nexport class RenderableEntity extends Entity {\r\n    constructor(width, height, baseTile) {\r\n        super(width, height, baseTile);\r\n        this.gone = false;\r\n        console.log(this.trackingTiles);\r\n        this.register();\r\n    }\r\n    move(dx, dy) {\r\n        const out = super.move(dx, dy);\r\n        this.register();\r\n        return out;\r\n    }\r\n    respawn(tile) {\r\n        super.respawn(tile);\r\n        this.register();\r\n    }\r\n    render(ctx) {\r\n    }\r\n    kill() {\r\n        this.gone = true;\r\n    }\r\n    isOnTile(tile) {\r\n        if (this.gone)\r\n            return false;\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                if (this.trackingTiles[x][y].view.tile.id === tile.id) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    register() {\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                this.trackingTiles[x][y].view.track(this);\r\n            }\r\n        }\r\n    }\r\n    renderInContext(renderer, tile) {\r\n        const renderHistory = new Set();\r\n        window.rh = renderHistory;\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                const tracker = this.trackingTiles[x][y];\r\n                if (tracker.view.tile === tile) {\r\n                    const renderKey = `${tracker.view.orientation}/${tracker.pt.x - tracker.onEntityX}/${tracker.pt.y - tracker.onEntityY}`;\r\n                    if (!renderHistory.has(renderKey)) {\r\n                        renderHistory.add(renderKey);\r\n                        renderer.ctx.save();\r\n                        renderer.applyOrientation(dirMtxInverse(tracker.view.orientation));\r\n                        renderer.ctx.translate((tracker.pt.x - tracker.onEntityX) * TILE_SIZE, (tracker.pt.y - tracker.onEntityY) * TILE_SIZE);\r\n                        this.render(renderer.ctx);\r\n                        renderer.ctx.restore();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RenderableEntity.ts\n// module id = 7\n// module chunks = 0","import { App } from \"./App\";\r\nconst app = new App();\r\nwindow.app = app;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 8\n// module chunks = 0","import { Renderer } from \"./Renderer\";\r\nimport * as testLevels from './testLevels';\r\nimport { Cursor } from \"./Cursor\";\r\nimport { Player } from \"./Player\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst level = testLevels.hubRoom();\r\nconst movementKeys = {\r\n    w: 3 /* top */,\r\n    a: 2 /* left */,\r\n    s: 1 /* bottom */,\r\n    d: 0 /* right */\r\n};\r\nconst shootKeys = {\r\n    i: 3 /* top */,\r\n    l: 0 /* right */,\r\n    k: 1 /* bottom */,\r\n    j: 2 /* left */\r\n};\r\nconst PLAYER_SPEED = 5 / 1000;\r\nexport class App {\r\n    constructor() {\r\n        this.stepables = new Set();\r\n        this.vel = new Cursor({ x: 0, y: 0 });\r\n        this.monitorKeys = {\r\n            w: false,\r\n            a: false,\r\n            s: false,\r\n            d: false\r\n        };\r\n        this.interactLock = false;\r\n        this.can = document.getElementById(\"can\");\r\n        this.renderer = new Renderer(this.can);\r\n        requestAnimationFrame(t => requestAnimationFrame((nt) => this.tick(nt, nt - t, Math.random())));\r\n        document.onkeydown = (e) => {\r\n            this.keyDown(e);\r\n        };\r\n        document.onkeyup = (e) => {\r\n            this.keyUp(e);\r\n        };\r\n        this.can.ondblclick = (e) => {\r\n            this.can.requestPointerLock();\r\n            this.allEvt(e);\r\n        };\r\n        this.can.onmousemove = (e) => {\r\n            if (document.pointerLockElement === this.can) {\r\n                if (Math.abs(e.movementX) < 200 && Math.abs(e.movementY) < 200)\r\n                    this.player.move(e.movementX / TILE_SIZE, e.movementY / TILE_SIZE);\r\n            }\r\n            this.allEvt(e);\r\n        };\r\n        this.player = new Player(level.getView(0).getNeighbor(0 /* right */), this);\r\n        this.cam = this.player.center.clone();\r\n    }\r\n    tick(t, dt, wat) {\r\n        if (this.can.width !== innerWidth || this.can.height !== innerHeight) {\r\n            this.can.width = innerWidth;\r\n            this.can.height = innerHeight;\r\n        }\r\n        this.tryMove(dt);\r\n        for (let stepable of this.stepables) {\r\n            if (!stepable.step(dt)) {\r\n                this.stepables.delete(stepable);\r\n            }\r\n        }\r\n        const ctr = this.locCam || this.player.center;\r\n        this.cam.copy(ctr);\r\n        const offsetX = 0;\r\n        const offsetY = 0;\r\n        ctr.view.stepOn(t);\r\n        if (!this.cam.move(offsetX, offsetY)) {\r\n            console.log(\"wat\");\r\n        }\r\n        this.renderer.render(this.cam.view, this.cam.pt.x, this.cam.pt.y, t, offsetX, offsetY);\r\n        if (this.watNumber !== wat)\r\n            console.log('wat');\r\n        this.watNumber = wat;\r\n        requestAnimationFrame((nt) => this.tick(nt, nt - t, wat));\r\n    }\r\n    keyDown(e) {\r\n        if (e.key in this.monitorKeys) {\r\n            this.monitorKeys[e.key] = true;\r\n        }\r\n        if (e.key === \"e\" && !this.interactLock) {\r\n            this.interactLock = true;\r\n            this.player.center.view.interact(performance.now());\r\n        }\r\n        if (e.key in shootKeys) {\r\n            this.player.shoot(shootKeys[e.key]);\r\n        }\r\n        this.allEvt(e);\r\n    }\r\n    allEvt(e) {\r\n        if (e.shiftKey && !this.locCam) {\r\n            this.locCam = this.player.center.clone();\r\n        }\r\n        if (!e.shiftKey) {\r\n            this.locCam = null;\r\n        }\r\n    }\r\n    keyUp(e) {\r\n        if (e.key in this.monitorKeys) {\r\n            this.monitorKeys[e.key] = false;\r\n        }\r\n        if (e.key === \"e\") {\r\n            this.interactLock = false;\r\n        }\r\n        if (e.key === \"h\") {\r\n            this.player.respawn(level.getView(0));\r\n        }\r\n        this.allEvt(e);\r\n    }\r\n    tryMove(dt) {\r\n        this.vel.x = 0;\r\n        this.vel.y = 0;\r\n        for (let key in movementKeys) {\r\n            if (this.monitorKeys[key]) {\r\n                this.vel.step(movementKeys[key], PLAYER_SPEED * dt);\r\n            }\r\n        }\r\n        if (this.vel.x !== 0 || this.vel.y !== 0) {\r\n            this.player.move(this.vel.x, this.vel.y);\r\n        }\r\n        // if(this.posn.x > 1){\r\n        //     if(!this.tryStep(Side.right)){\r\n        //         this.posn.x = 1\r\n        //     }\r\n        // }\r\n        // if (this.posn.y > 1) {\r\n        //     if (!this.tryStep(Side.bottom)) {\r\n        //         this.posn.y = 1;\r\n        //     }\r\n        // }\r\n        // if (this.posn.x < 0) {\r\n        //     if (!this.tryStep(Side.left)) {\r\n        //         this.posn.x = 0;\r\n        //     }\r\n        // }\r\n        // if (this.posn.y < 0) {\r\n        //     if (!this.tryStep(Side.top)) {\r\n        //         this.posn.y = 0;\r\n        //     }\r\n        // }\r\n    }\r\n    // tryStep(dir: Side){\r\n    //     if(this.view.getNeighbor(dir)){\r\n    //         this.view = this.view.getNeighbor(dir);\r\n    //         this.posn.step(dir,-1);\r\n    //         return true;\r\n    //     }\r\n    //     return false;\r\n    // }\r\n    addStepable(stepable) {\r\n        this.stepables.add(stepable);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.ts\n// module id = 9\n// module chunks = 0","import { Projector } from \"./Projector\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nfunction maxSquareSquare(z) {\r\n    return Math.max(z ** 2, (z + 1) ** 2);\r\n}\r\nconst debugColors = ['red', 'green', 'blue', 'cyan', 'orange'];\r\nfunction debugColor() {\r\n    return debugColors[(Math.random() * debugColors.length) | 0];\r\n}\r\nconst DEBUG = false;\r\nconst SUPERDebug = false;\r\nconst TARGET_SIZE = 12;\r\n// const DEBUGMAP = {7:true, 3:true};\r\nexport class Renderer {\r\n    constructor(can) {\r\n        this.projector = new Projector();\r\n        this.can = can;\r\n        this.ctx = can.getContext('2d');\r\n    }\r\n    render(root, offsetX, offsetY, t, displayOffsetX, displayOffsetY) {\r\n        const scale = this.scale = 1 / Math.max(TILE_SIZE * TARGET_SIZE / this.can.width, TILE_SIZE * TARGET_SIZE / this.can.height);\r\n        const items = this.projector.project(root, offsetX, offsetY, this.can.width / TILE_SIZE / 2 / scale, this.can.height / TILE_SIZE / 2 / scale, displayOffsetX, displayOffsetY);\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.fillRect(0, 0, this.can.width, this.can.height);\r\n        this.ctx.save();\r\n        this.ctx.translate(this.can.width / 2, this.can.height / 2);\r\n        this.ctx.scale(scale, scale);\r\n        this.ctx.translate((displayOffsetX * TILE_SIZE), (displayOffsetY * TILE_SIZE));\r\n        // this.ctx.scale(TILE_SIZE, TILE_SIZE);\r\n        for (let item of items) {\r\n            // if (DEBUG) console.log(item);\r\n            this.ctx.save();\r\n            if (SUPERDebug) {\r\n                if ((item.x !== 0 || item.y !== -2)) {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.rect((item.x - offsetX) * TILE_SIZE, (item.y - offsetY) * TILE_SIZE, TILE_SIZE, TILE_SIZE);\r\n                    this.ctx.clip();\r\n                }\r\n                else {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.moveTo(1000 * Math.cos(item.minTheta), 1000 * Math.sin(item.minTheta));\r\n                    this.ctx.lineTo(0, 0);\r\n                    this.ctx.lineTo(1000 * Math.cos(item.maxTheta), 1000 * Math.sin(item.maxTheta));\r\n                    this.ctx.strokeStyle = 'orange';\r\n                    this.ctx.stroke();\r\n                }\r\n            }\r\n            const r = Math.sqrt(maxSquareSquare(item.x - offsetX) +\r\n                maxSquareSquare(item.y - offsetY)) + Math.sqrt(2);\r\n            if (!item.isRoot && item.anglesLength !== 2) {\r\n                this.ctx.beginPath();\r\n                for (let i = 0; i < item.anglesLength; i += 2) {\r\n                    const fromAng = item.angles[i];\r\n                    const toAng = item.angles[i + 1];\r\n                    if (fromAng === toAng)\r\n                        continue;\r\n                    const sf = Math.abs(1 / Math.cos((fromAng - toAng) / 2));\r\n                    this.ctx.moveTo(0, 0);\r\n                    this.ctx.lineTo(Math.cos(fromAng) * r * TILE_SIZE * sf, Math.sin(fromAng) * r * TILE_SIZE * sf);\r\n                    // this.ctx.arc(0, 0, r * TILE_SIZE, fromAng, toAng);\r\n                    this.ctx.lineTo(Math.cos(toAng) * r * TILE_SIZE * sf, Math.sin(toAng) * r * TILE_SIZE * sf);\r\n                    this.ctx.lineTo(0, 0);\r\n                }\r\n                if (DEBUG) {\r\n                    this.ctx.lineWidth = 1;\r\n                    this.ctx.strokeStyle = \"pink\";\r\n                    this.ctx.stroke();\r\n                }\r\n                this.ctx.clip();\r\n            }\r\n            this.ctx.translate(((item.x - offsetX) * TILE_SIZE), ((item.y - offsetY) * TILE_SIZE));\r\n            this.applyOrientation(item.view.orientation);\r\n            // this.ctx.beginPath();\r\n            // this.ctx.rect(0, 0, 1, 1);\r\n            // this.ctx.clip();\r\n            item.view.tile.render(this.ctx, t);\r\n            if (DEBUG) {\r\n                this.ctx.fillStyle = \"black\";\r\n                this.ctx.fillText(`${item.view.id}`, 10, 10);\r\n            }\r\n            let entitiesInit = false;\r\n            const tile = item.view.tile;\r\n            for (let entity of item.view.tile.entities) {\r\n                const isOnTile = entity.isOnTile(item.view.tile);\r\n                if (!isOnTile) {\r\n                    tile.entities.delete(entity);\r\n                }\r\n                else {\r\n                    if (!entitiesInit) {\r\n                        this.ctx.beginPath();\r\n                        this.ctx.rect(0, 0, TILE_SIZE, TILE_SIZE);\r\n                        this.ctx.clip();\r\n                        entitiesInit = true;\r\n                    }\r\n                    entity.renderInContext(this, item.view.tile);\r\n                }\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n        // this.ctx.beginPath();\r\n        // this.ctx.fillStyle = 'black';\r\n        // this.ctx.arc(0, 0, TILE_SIZE / 3, 0, Math.PI * 2);\r\n        // this.ctx.fill();\r\n        this.ctx.restore();\r\n        // this.ctx.beginPath();\r\n        // for (let x = (this.can.width / 2 - offsetX * TILE_SIZE) % TILE_SIZE - TILE_SIZE; x < this.can.width; x += TILE_SIZE) {\r\n        //     this.ctx.moveTo(x, 0);\r\n        //     this.ctx.lineTo(x, this.can.height);\r\n        // }\r\n        // for (let y = (this.can.height / 2 - offsetY * TILE_SIZE) % TILE_SIZE - TILE_SIZE; y < this.can.height; y += TILE_SIZE) {\r\n        //     this.ctx.moveTo(0, y);\r\n        //     this.ctx.lineTo(this.can.width, y);\r\n        // }    \r\n        // this.ctx.strokeStyle = 'rgba(255,255,255,1)';\r\n        // this.ctx.lineWidth = 1;\r\n        // this.ctx.stroke();\r\n    }\r\n    applyOrientation(orientation, doTranslate = true) {\r\n        const { ctx } = this;\r\n        if (doTranslate)\r\n            this.ctx.translate(0.5 * TILE_SIZE, 0.5 * TILE_SIZE);\r\n        ctx.rotate((orientation & 0b11) * Math.PI / 2);\r\n        if (orientation & 0b100)\r\n            ctx.scale(1, -1);\r\n        if (doTranslate)\r\n            this.ctx.translate(-0.5 * TILE_SIZE, -0.5 * TILE_SIZE);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Renderer.ts\n// module id = 10\n// module chunks = 0","import { LinearObjectPool } from \"./LinearObjectPool\";\r\nfunction trueMod(a, b) {\r\n    return ((a % b) + b) % b;\r\n}\r\nfunction reduceAngle(angle) {\r\n    return trueMod(angle + Math.PI, Math.PI * 2) - Math.PI;\r\n}\r\nfunction reduceAngleCentered(center, angle) {\r\n    return reduceAngle(angle - center) + center;\r\n}\r\nconst FUDGE_THETA = Math.PI / 100000;\r\nfunction greaterThanEqualsFavorsTrue(a, b) {\r\n    return a + FUDGE_THETA >= b;\r\n}\r\nconst DEBUG = false;\r\nconst ANGLE_RANGE = Math.PI / 100000;\r\nclass ProjectionPath {\r\n    constructor() {\r\n        this.angles = new Float64Array(32);\r\n        this.anglesLength = 0;\r\n    }\r\n    static id(view, x, y) {\r\n        return `${view.id},${x},${y}`;\r\n    }\r\n    init(view, x, y, isRoot = false, offsetX, offsetY) {\r\n        this.view = view;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.anglesLength = 0;\r\n        this.centerAngle = Math.atan2(y, x);\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        if (isRoot) {\r\n            //    this.angles.push(\r\n            //        0,\r\n            //        Math.PI / 2\r\n            //    );\r\n            for (let i = 0; i < 3; i++) {\r\n                this.angles[this.anglesLength++] = (Math.PI * 2 / 3 * (i + .5));\r\n                this.angles[this.anglesLength++] = (Math.PI * 2 / 3 * (i + 1.5));\r\n            }\r\n        }\r\n        else {\r\n            let minTheta = Infinity;\r\n            let maxTheta = -Infinity;\r\n            for (let ox = 0; ox < 2; ox++) {\r\n                for (let oy = 0; oy < 2; oy++) {\r\n                    const theta = reduceAngleCentered(this.centerAngle, Math.atan2(y - offsetY + oy, x - offsetX + ox));\r\n                    if (theta < minTheta)\r\n                        minTheta = theta;\r\n                    if (theta > maxTheta)\r\n                        maxTheta = theta;\r\n                }\r\n            }\r\n            this.minTheta = minTheta;\r\n            this.maxTheta = maxTheta;\r\n            this.angles[this.anglesLength++] = minTheta;\r\n            this.angles[this.anglesLength++] = minTheta;\r\n            this.angles[this.anglesLength++] = maxTheta;\r\n            this.angles[this.anglesLength++] = maxTheta;\r\n        }\r\n        this.id = ProjectionPath.id(view, x, y);\r\n        this.isRoot = isRoot;\r\n        return this;\r\n    }\r\n    addRange(from, to) {\r\n        this.addRangeImpl(reduceAngleCentered(this.centerAngle, from), reduceAngleCentered(this.centerAngle, to));\r\n    }\r\n    addRangeImpl(from, to) {\r\n        if (this.isRoot)\r\n            return;\r\n        if (DEBUG)\r\n            console.log('adding range', this.id, from, to);\r\n        if (to === from) {\r\n            return;\r\n        }\r\n        if (to < from) {\r\n            // console.log(to, from);\r\n            this.addRangeImpl(to, from);\r\n            return;\r\n        }\r\n        let startIndex = 0;\r\n        for (; startIndex < this.angles.length; startIndex++) {\r\n            if (startIndex % 2 === 1 ?\r\n                this.angles[startIndex] + FUDGE_THETA >= from\r\n                : this.angles[startIndex] >= from + FUDGE_THETA) {\r\n                break;\r\n            }\r\n        }\r\n        let endIndex = startIndex;\r\n        for (; endIndex < this.angles.length; endIndex++) {\r\n            if (endIndex % 2 === 1 ?\r\n                this.angles[endIndex] + FUDGE_THETA > to\r\n                : this.angles[endIndex] > FUDGE_THETA + to) {\r\n                break;\r\n            }\r\n        }\r\n        const startIsOutside = startIndex % 2 == 0;\r\n        const endIsOutside = endIndex % 2 == 0;\r\n        const lengthChange = startIndex - endIndex + (startIsOutside ? 1 : 0) + (endIsOutside ? 1 : 0);\r\n        this.angles.copyWithin(endIndex + lengthChange, endIndex, this.anglesLength);\r\n        this.anglesLength += lengthChange;\r\n        if (startIsOutside)\r\n            this.angles[startIndex++] = from;\r\n        if (endIsOutside)\r\n            this.angles[startIndex++] = to;\r\n        // if (startIsOutside && endIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, from, to);\r\n        // } else if (startIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, from);\r\n        // } else if (endIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, to);\r\n        // } else {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex);\r\n        // }\r\n        return;\r\n    }\r\n    clean() {\r\n        this.view = null; //this ref could be very costly\r\n    }\r\n}\r\nconst EDGE_GLITCH_REDUCTION_DIST = 1 / 100000;\r\nexport class Projector {\r\n    constructor() {\r\n        this.lookup = new Map();\r\n        this.projectionPathPool = new LinearObjectPool(() => new ProjectionPath());\r\n    }\r\n    project(root, offsetX, offsetY, renderRadiusX, renderRadiusY, displayOffsetX, displayOffestY) {\r\n        this.projectionPathPool.done();\r\n        this.que = [];\r\n        this.lookup.clear();\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        this.renderRadiusX = renderRadiusX;\r\n        this.renderRadiusY = renderRadiusY;\r\n        this.displayOffsetX = displayOffsetX;\r\n        this.displayOffsetY = displayOffestY;\r\n        const addRoot = (root, x, y) => {\r\n            if (!root)\r\n                return;\r\n            if (x === 0 && y === 0) {\r\n                if (offsetX <= EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(2 /* left */), -1, y);\r\n                }\r\n                if (offsetX >= 1 - EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(0 /* right */), 1, y);\r\n                }\r\n                if (offsetY <= EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(3 /* top */), x, -1);\r\n                }\r\n                if (offsetY >= 1 - EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(1 /* bottom */), x, 1);\r\n                }\r\n            }\r\n            const rootPath = this.projectionPathPool.pop().init(root, x, y, true, offsetX, offsetY);\r\n            this.lookup.set(rootPath.id, rootPath);\r\n            this.que.push(rootPath);\r\n        };\r\n        addRoot(root, 0, 0);\r\n        while (this.que.length > 0) {\r\n            const item = this.que.shift();\r\n            this.considerItem(item);\r\n            if (this.que.length > 1000) {\r\n                console.warn('oversize que');\r\n                break;\r\n            }\r\n        }\r\n        return this.lookup.values();\r\n    }\r\n    considerItem(item) {\r\n        if (Math.sqrt(item.x ** 2 + item.y ** 2) > 100)\r\n            return;\r\n        if (item.x >= 0 || item.isRoot)\r\n            this.considerSide(item, true, 1, item.view.getNeighbor(0), item.x + 1, item.y);\r\n        if (item.y >= 0 || item.isRoot)\r\n            this.considerSide(item, false, 1, item.view.getNeighbor(1), item.x, item.y + 1);\r\n        if (item.x < 1 || item.isRoot)\r\n            this.considerSide(item, true, 0, item.view.getNeighbor(2), item.x - 1, item.y);\r\n        if (item.y < 1 || item.isRoot)\r\n            this.considerSide(item, false, 0, item.view.getNeighbor(3), item.x, item.y - 1);\r\n    }\r\n    /**\r\n     *\r\n     * @param axis true = line goes up down\r\n     */\r\n    considerSide(item, axis, offsetZ, nextTile, nextX, nextY) {\r\n        if (nextX - this.offsetX + this.displayOffsetX > this.renderRadiusX ||\r\n            nextX - this.offsetX + 1 + this.displayOffsetX < -this.renderRadiusX ||\r\n            nextY - this.offsetY + this.displayOffsetY > this.renderRadiusY ||\r\n            nextY - this.offsetY + 1 + this.displayOffsetY < -this.renderRadiusY)\r\n            return;\r\n        if (!nextTile)\r\n            return;\r\n        if (DEBUG)\r\n            console.log(\"consider side\", axis, offsetZ, nextTile, nextX, nextY, item.id);\r\n        const lineZ = axis ? item.x + offsetZ - this.offsetX : item.y + offsetZ - this.offsetY;\r\n        const topU = axis ? item.y - this.offsetY : item.x - this.offsetX;\r\n        const bottomU = topU + 1;\r\n        function makeAng(u) {\r\n            return axis ? Math.atan2(u, lineZ) : -Math.atan2(u, lineZ) + Math.PI / 2;\r\n        }\r\n        function projectAng(angle) {\r\n            if (Math.abs(reduceAngle(angle + (axis ? Math.PI / 2 : Math.PI))) < ANGLE_RANGE) {\r\n                return makeAng(topU);\r\n            }\r\n            else if (Math.abs(reduceAngle(angle + (axis ? Math.PI / 2 : 0))) < ANGLE_RANGE) {\r\n                return makeAng(bottomU);\r\n            }\r\n            const slopeUZ = axis ? Math.tan(angle) : Math.tan(Math.PI / 2 - angle);\r\n            const colU = slopeUZ * lineZ;\r\n            if (DEBUG)\r\n                console.log(\"proj\", angle, slopeUZ, colU);\r\n            if ((axis ? Math.cos(angle) : Math.sin(angle)) * lineZ < 0) {\r\n                // return projectAng(-angle);\r\n                return (!axis ? Math.cos(angle) : Math.sin(angle)) < 0 ? makeAng(topU) : makeAng(bottomU);\r\n            }\r\n            if (colU < topU) {\r\n                return makeAng(topU);\r\n            }\r\n            else if (colU > bottomU) {\r\n                return makeAng(bottomU);\r\n            }\r\n            else {\r\n                return angle;\r\n            }\r\n        }\r\n        let newItem = null;\r\n        const considerAngleRange = (fromAng, toAng) => {\r\n            const newFromAng = projectAng(fromAng);\r\n            const newToAng = projectAng(toAng);\r\n            if (DEBUG)\r\n                console.log(\"proj section\", item.id, fromAng, toAng, newFromAng, newToAng);\r\n            if (newFromAng === false || newToAng === false) {\r\n                return;\r\n            }\r\n            if (newFromAng !== newToAng) {\r\n                if (newItem === null) {\r\n                    const key = ProjectionPath.id(nextTile, nextX, nextY);\r\n                    if (this.lookup.has(key)) {\r\n                        newItem = this.lookup.get(key);\r\n                    }\r\n                    else {\r\n                        newItem = this.projectionPathPool.pop();\r\n                        newItem.init(nextTile, nextX, nextY, false, this.offsetX, this.offsetY);\r\n                        this.lookup.set(key, newItem);\r\n                        this.que.push(newItem);\r\n                    }\r\n                }\r\n                newItem.addRange(newFromAng, newToAng);\r\n            }\r\n        };\r\n        const foldAngleRange = (fromAng, toAng) => {\r\n            if (Math.abs(reduceAngle(toAng - fromAng)) > Math.PI / 2) {\r\n                const mid = reduceAngle((fromAng + toAng) / 2);\r\n                considerAngleRange(reduceAngle(fromAng), mid);\r\n                considerAngleRange(mid, reduceAngle(toAng));\r\n                return;\r\n            }\r\n            else {\r\n                considerAngleRange(reduceAngle(fromAng), reduceAngle(toAng));\r\n            }\r\n        };\r\n        for (let i = 0; i < item.angles.length / 2; i++) {\r\n            const fromAng = item.angles[2 * i];\r\n            const toAng = item.angles[2 * i + 1];\r\n            if (fromAng === toAng)\r\n                continue;\r\n            foldAngleRange(fromAng, toAng);\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Projector.ts\n// module id = 11\n// module chunks = 0","export class LinearObjectPool {\r\n    constructor(makeT, size = 64) {\r\n        this.usedIndex = 0;\r\n        this.makeT = makeT;\r\n        this.items = [...Array(size)].map(() => makeT());\r\n    }\r\n    pop() {\r\n        if (this.usedIndex + 1 >= this.items.length) {\r\n            this.items.push(this.makeT());\r\n            window.usedSize = this.items.length;\r\n        }\r\n        return this.items[this.usedIndex++];\r\n    }\r\n    done() {\r\n        for (let i = this.usedIndex; i >= 0; i--) {\r\n            this.items[i].clean();\r\n        }\r\n        this.usedIndex = 0;\r\n    }\r\n    clean() {\r\n        this.done();\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/LinearObjectPool.ts\n// module id = 12\n// module chunks = 0","import { TileGrid } from \"./TileGrid\";\r\nimport { ColorTile } from \"./ColorTile\";\r\nimport { strictCompose } from \"./compose\";\r\nimport { TickTackToeTile } from \"./tickTackToe/TickTackToeTile\";\r\nfunction colorTile(xc, yc, color) {\r\n    return (next) => (x, y) => {\r\n        if (x === xc && y === yc) {\r\n            return new ColorTile(color);\r\n        }\r\n        return next(x, y);\r\n    };\r\n}\r\nfunction dynamicColor(w, h, base = 255) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(`rgb(${((x / w) ** .5 * 255) | 0},${base},${((y / h) ** .5 * 255) | 0})`);\r\n    };\r\n}\r\nfunction rain(sf, offset = 0) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(`hsl(${(((x + offset) / sf) * 360) | 0},50%,50%)`);\r\n    };\r\n}\r\nfunction checkers(...colors) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(colors[(x + y) % colors.length]);\r\n    };\r\n}\r\nfunction cardinal(xc, yc) {\r\n    return strictCompose([\r\n        colorTile(xc + 1, yc, 'red'),\r\n        colorTile(xc, yc + 1, 'green'),\r\n        colorTile(xc - 1, yc, 'blue'),\r\n        colorTile(xc, yc - 1, 'cyan')\r\n    ]);\r\n}\r\nfunction tickTackToeLayer(n = 3) {\r\n    return (next) => (x, y) => {\r\n        return new TickTackToeTile(n);\r\n    };\r\n}\r\nfunction fullColor(color) {\r\n    return solidColorTiles(color);\r\n}\r\nfunction solidColorTiles(color) {\r\n    return (next) => (x, y) => new ColorTile(color);\r\n}\r\nexport function flatSpace() {\r\n    const grid = new TileGrid(9, 9);\r\n    grid.get(2, 1).isolate();\r\n    return grid.get(1, 1);\r\n}\r\nexport function portSpace() {\r\n    const grid1 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"red\")\r\n    ]);\r\n    const grid2 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"blue\")\r\n    ]);\r\n    grid1.get(4, 4).link(0 /* right */, grid2.get(4, 4));\r\n    grid2.get(8, 8).link(1 /* bottom */, grid1.get(0, 0));\r\n    grid2.get(6, 4).link(0 /* right */, grid1.get(2, 4));\r\n    return grid1.get(4, 7);\r\n}\r\nexport function shortWay() {\r\n    const grid = new TileGrid(11, 5, [\r\n        cardinal(5, 2),\r\n        dynamicColor(10, 5)\r\n    ]);\r\n    for (let i = 2; i < 9; i++) {\r\n        grid.get(i, 2).isolate();\r\n    }\r\n    for (let i = 0; i < 2; i++) {\r\n        grid.get(1, i).link(0 /* right */, grid.get(8, i));\r\n    }\r\n    return grid.get(0, 4);\r\n}\r\nexport function threeTurns() {\r\n    const grid = new TileGrid(7, 7, [\r\n        cardinal(2, 2),\r\n        colorTile(0, 0, 'pink'),\r\n        dynamicColor(7, 7)\r\n    ]);\r\n    for (let i = 0; i < 7; i++) {\r\n        if (i === 1 || i === 5) {\r\n            continue;\r\n        }\r\n        grid.get(i, 3).isolate();\r\n        grid.get(3, i).isolate();\r\n    }\r\n    grid.get(3, 5).link(0 /* right */, grid.get(5, 2), 1 /* bottom */);\r\n    return grid.get(2, 2);\r\n}\r\nexport function bridge() {\r\n    const grid = new TileGrid(5, 5, [\r\n        cardinal(2, 2),\r\n        dynamicColor(5, 5)\r\n    ]);\r\n    const bridge = new ColorTile('orange');\r\n    console.log(grid);\r\n    grid.get(0, 0).link(3 /* top */, bridge);\r\n    grid.get(4, 0).link(3 /* top */, bridge, 3 /* top */, { reflect: true });\r\n    grid.get(4, 4).link(0 /* right */, bridge);\r\n    return grid.get(2, 2);\r\n}\r\nexport function fastLane() {\r\n    const S = 27;\r\n    const grid = new TileGrid(S, 4, [\r\n        dynamicColor(S, 4)\r\n    ]);\r\n    for (let i = 0; i < S; i += 2) {\r\n        for (let j = 0; j < 2; j++) {\r\n            if (i < S - 2)\r\n                grid.get(i, j).link(0 /* right */, grid.get(i + 2, j));\r\n            if (i < S - 1)\r\n                grid.get(i + 1, j).isolate();\r\n        }\r\n    }\r\n    return grid.get(0, 3);\r\n}\r\nexport function fastLane2() {\r\n    const shortLength = 10;\r\n    const zoomLevel = 5;\r\n    const longGrid = new TileGrid(shortLength * zoomLevel, 2, [\r\n        rain(shortLength * zoomLevel / 3)\r\n    ]);\r\n    for (let o = 0; o < zoomLevel; o++) {\r\n        const shortGrid = new TileGrid(shortLength, 2, [\r\n            rain(shortLength / 3, o / zoomLevel)\r\n        ]);\r\n        for (let i = 0; i < shortLength; i++) {\r\n            const targ = longGrid.get(i * zoomLevel + o, 0);\r\n            shortGrid.get(i, 1).link(1 /* bottom */, targ);\r\n        }\r\n    }\r\n    return longGrid.get(0, 1);\r\n}\r\nexport function ballPort() {\r\n    const grid1 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"red\")\r\n    ]);\r\n    const grid2 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"blue\")\r\n    ]);\r\n    const center1 = grid1.get(4, 4);\r\n    const center2 = grid2.get(4, 4);\r\n    let bridge;\r\n    for (let i = 0; i < 4; i++) {\r\n        const reverse = (i + 2) % 4;\r\n        if (i % 2 === 0)\r\n            bridge = new ColorTile(\"pink\");\r\n        center1.getReference(i).to.link(reverse, bridge);\r\n        center2.getReference(reverse).to.link(i, bridge);\r\n    }\r\n    return grid1.get(4, 7);\r\n}\r\nexport function branches(n = 7) {\r\n    if (n === 0) {\r\n        return new ColorTile(\"red\");\r\n    }\r\n    const color = `hsl(${Math.random() * 360},50%,50%)`;\r\n    const out = new ColorTile(color);\r\n    function addSide(side) {\r\n        const bridge = new ColorTile(color);\r\n        out.link(side, bridge, 1 /* bottom */);\r\n        bridge.link(3 /* top */, branches(n - 1), 1 /* bottom */);\r\n    }\r\n    addSide(3 /* top */);\r\n    addSide(1 /* bottom */);\r\n    addSide(2 /* left */);\r\n    addSide(0 /* right */);\r\n    return out;\r\n}\r\nexport function branches2() {\r\n    const S = 4;\r\n    function inner(n = 7) {\r\n        const color = `hsl(${Math.random() * 360},50%,50%)`;\r\n        if (n === 0) {\r\n            return new TileGrid(S, S, [\r\n                solidColorTiles(color)\r\n            ]);\r\n        }\r\n        const out = new TileGrid(S, S, [\r\n            solidColorTiles(color)\r\n        ]);\r\n        const north = inner(n - 1);\r\n        const east = inner(n - 1);\r\n        const west = inner(n - 1);\r\n        for (let i = 0; i < S; i++) {\r\n            out.get(i, 0).link(3 /* top */, north.get(i, S - 1));\r\n            out.get(0, S - 1 - i).link(2 /* left */, east.get(i, S - 1), 1 /* bottom */);\r\n            out.get(S - 1, i).link(0 /* right */, west.get(i, S - 1), 1 /* bottom */);\r\n        }\r\n        return out;\r\n    }\r\n    return inner().get(Math.floor(S / 2), S - 1);\r\n}\r\nexport function mirror() {\r\n    const grid = new TileGrid(5, 5, [\r\n        dynamicColor(5, 5)\r\n    ]);\r\n    for (let i = 1; i < 4; i++) {\r\n        grid.get(2, i).link(0 /* right */, grid.get(2, i), 0 /* right */, {\r\n            reflect: true\r\n        });\r\n    }\r\n    return grid.get(0, 4);\r\n}\r\nexport function tickTackToeBasic() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer()\r\n    ]);\r\n    return grid.get(0, 2);\r\n}\r\nexport function tickTackToeDonut() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer()\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i));\r\n        grid.get(i, 0).link(3 /* top */, grid.get(i, 2));\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeDonutOffset() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(4)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i));\r\n        grid.get((i + 1) % 3, 0).link(3 /* top */, grid.get(i, 2));\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeKlign() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(4)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i), 0 /* right */, { reflect: false });\r\n        grid.get(i, 0).link(3 /* top */, grid.get(2 - i, 2), 1 /* bottom */, { reflect: true });\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeMirror() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(5)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(0, i), 2 /* left */, { reflect: true, addReverse: false });\r\n        grid.get(2, i).link(0 /* right */, grid.get(2, i), 0 /* right */, { reflect: true, addReverse: false });\r\n        grid.get(i, 2).link(1 /* bottom */, grid.get(i, 2), 1 /* bottom */, { reflect: true, addReverse: false });\r\n        grid.get(i, 0).link(3 /* top */, grid.get(i, 0), 3 /* top */, { reflect: true, addReverse: false });\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function mobius(W = 5, H = 5) {\r\n    const grid = new TileGrid(W, H, [\r\n        dynamicColor(W, H)\r\n    ]);\r\n    for (let i = 0; i < H; i++) {\r\n        grid.get(W - 1, i).link(0 /* right */, grid.get(0, H - i - 1), 2 /* left */, {\r\n            reflect: true\r\n        });\r\n    }\r\n    return grid.get(0, H - 1);\r\n}\r\nexport function spiral(S = 10) {\r\n    let len = S - 2;\r\n    let dir = 0 /* right */;\r\n    const grid = new TileGrid(S, S, [\r\n        dynamicColor(S, S)\r\n    ]);\r\n    let tile = grid.get(0, S - 1);\r\n    while (len > 2) {\r\n        len -= 1 / 2;\r\n        for (let i = 0; i < len; i++) {\r\n            tile = tile.links[dir].to;\r\n        }\r\n        const ot = tile;\r\n        const nextDir = (dir - 1) & 0b11;\r\n        const mid = tile.links[dir].to;\r\n        tile = mid.links[nextDir].to;\r\n        mid.isolate();\r\n        ot.link(dir, tile, (nextDir + 2) & 3);\r\n        dir = nextDir;\r\n    }\r\n    return grid.get(0, S - 1);\r\n}\r\nexport function makeHubRoom(worlds, color = 'gold') {\r\n    const root = [new ColorTile('red'), new ColorTile('pink')];\r\n    for (let i = 0; i < worlds.length - 1; i++) {\r\n        const left = worlds[i];\r\n        const right = worlds[(i + 1)];\r\n        if (left instanceof Array && right instanceof Array) {\r\n            left[1].forEach((e, i) => {\r\n                e.link(0 /* right */, right[0][i]);\r\n            });\r\n        }\r\n    }\r\n    const out = worlds.reduceRight(([rightTile, rightBridge], worldRoot) => {\r\n        const hubTile = new ColorTile(color);\r\n        const hubBridge = new ColorTile(color);\r\n        const leftBridge = new ColorTile(color);\r\n        const leftTile = new ColorTile(color);\r\n        hubTile.link(0 /* right */, rightTile);\r\n        hubBridge.link(0 /* right */, rightBridge);\r\n        leftTile.link(0 /* right */, hubTile);\r\n        leftBridge.link(0 /* right */, hubBridge);\r\n        hubBridge.link(1 /* bottom */, hubTile);\r\n        if (worldRoot !== false)\r\n            hubBridge.link(3 /* top */, worldRoot instanceof Array ? worldRoot[1][0] : worldRoot);\r\n        if (worldRoot instanceof Array)\r\n            leftBridge.link(3 /* top */, worldRoot[0][0]);\r\n        hubTile.link(3 /* top */, hubBridge);\r\n        leftBridge.link(1 /* bottom */, leftTile);\r\n        return (worldRoot instanceof Array) ? [leftTile, leftBridge] : [hubTile, hubBridge];\r\n    }, root);\r\n    console.log(root);\r\n    const base = root.map(e => e.links[2 /* left */].to);\r\n    root.map(e => e.isolate());\r\n    return [out, base];\r\n}\r\nexport function hubRoom() {\r\n    const data = makeHubRoom([\r\n        makeHubRoom([\r\n            portSpace(),\r\n            ballPort(),\r\n            mirror(),\r\n            bridge()\r\n        ], 'pink'),\r\n        makeHubRoom([\r\n            shortWay(),\r\n            fastLane(),\r\n            fastLane2(),\r\n            threeTurns()\r\n        ], 'cyan'),\r\n        makeHubRoom([\r\n            branches(),\r\n            branches2(),\r\n        ], 'red'),\r\n        makeHubRoom([\r\n            tickTackToeBasic(),\r\n            tickTackToeDonut(),\r\n            tickTackToeKlign(),\r\n            tickTackToeMirror(),\r\n            tickTackToeDonutOffset()\r\n        ], 'grey'),\r\n        makeHubRoom([\r\n            mobius(),\r\n            mobius(30),\r\n            spiral()\r\n        ], 'blue')\r\n    ]);\r\n    return data[0][1];\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/testLevels.ts\n// module id = 13\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nexport class TileGrid {\r\n    constructor(width, height, layers = []) {\r\n        const getTiles = layers.reduce((a, b) => (next) => a(b(next)), (x) => x)((x, y) => new Tile());\r\n        this.tiles = [...Array(height)].map((_, y) => [...Array(width)].map((_, x) => getTiles(x, y)));\r\n        this.tiles.forEach((row, y) => {\r\n            row.forEach((tile, x) => {\r\n                if (y !== 0) {\r\n                    this.tiles[y - 1][x].link(1 /* bottom */, tile);\r\n                }\r\n                if (x !== 0) {\r\n                    row[x - 1].link(0 /* right */, tile);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    get(x, y) {\r\n        return this.tiles[y][x];\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TileGrid.ts\n// module id = 14\n// module chunks = 0","import { makeDirMtx, dirMtxProduct } from \"./DirMtx\";\r\nimport { reverseSide } from \"./Side\";\r\nexport class SideReference {\r\n    constructor(to, mtx, destSide) {\r\n        this.to = to;\r\n        this.mtx = mtx;\r\n        this.destSide = destSide;\r\n    }\r\n    static fromOpts(toTile, fromSide, destSide, reflect) {\r\n        return new SideReference(toTile, dirMtxProduct(makeDirMtx(-reverseSide(destSide), reflect), fromSide), destSide);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SideReference.ts\n// module id = 15\n// module chunks = 0","import { dirMtxApply, dirMtxInverse, dirMtxProductImpl } from \"./DirMtx\";\r\nconst lookupMaps = [...Array(8)].map((i) => {\r\n    return new WeakMap();\r\n});\r\nexport class TileView {\r\n    static lookup(tile, orientation) {\r\n        return tile.tileViews[orientation];\r\n        // const map = lookupMaps[orientation];\r\n        // if(!map.has(tile)){\r\n        //     const view = new TileView(tile, orientation);\r\n        //     map.set(tile, view);\r\n        //     return view;\r\n        // }\r\n        // return map.get(tile);\r\n    }\r\n    constructor(tile, orientation) {\r\n        this.tile = tile;\r\n        this.orientation = orientation;\r\n        this.id = `${tile.id},${orientation}`;\r\n    }\r\n    getNeighbor(i) {\r\n        const edge = this.tile.getReference(dirMtxApply(dirMtxInverse(this.orientation), i));\r\n        if (edge) {\r\n            return TileView.lookup(edge.to, dirMtxProductImpl(this.orientation, edge.mtx));\r\n        }\r\n        return null;\r\n    }\r\n    stepOn(t) {\r\n        this.tile.stepOn(t);\r\n    }\r\n    interact(t) {\r\n        this.tile.interact(t);\r\n    }\r\n    track(entity) {\r\n        this.tile.track(entity);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TileView.ts\n// module id = 16\n// module chunks = 0","import { ColorTile } from \"../ColorTile\";\r\nimport { TILE_SIZE } from \"../opts\";\r\nimport { strictCompose } from \"../compose\";\r\nvar Turn;\r\n(function (Turn) {\r\n    Turn[Turn[\"RED\"] = -1] = \"RED\";\r\n    Turn[Turn[\"NONE\"] = 0] = \"NONE\";\r\n    Turn[Turn[\"BLACK\"] = 1] = \"BLACK\";\r\n})(Turn || (Turn = {}));\r\nfunction turnColor(turn) {\r\n    return turn === Turn.RED ? \"RED\" : turn === Turn.BLACK ? \"black\" : \"grey\";\r\n}\r\nclass TickTackToeGame {\r\n    constructor() {\r\n        this.turn = Turn.RED;\r\n        this.won = Turn.NONE;\r\n        this.blankTiles = 0;\r\n    }\r\n}\r\nconst MARGIN = TILE_SIZE / 6;\r\nfunction singleStepMovement(dir) {\r\n    return (t) => {\r\n        if (!t)\r\n            return null;\r\n        return t.getNeighbor(dir);\r\n    };\r\n}\r\nfunction movement(dirs) {\r\n    return strictCompose(dirs.map(singleStepMovement));\r\n}\r\nconst movementMethods = [\r\n    [3 /* top */, 1 /* bottom */].map(singleStepMovement),\r\n    [2 /* left */, 0 /* right */].map(singleStepMovement),\r\n    [\r\n        [2 /* left */, 1 /* bottom */],\r\n        [3 /* top */, 0 /* right */]\r\n    ].map(movement),\r\n    [\r\n        [1 /* bottom */, 2 /* left */],\r\n        [0 /* right */, 3 /* top */]\r\n    ].map(movement),\r\n    [\r\n        [2 /* left */, 3 /* top */],\r\n        [1 /* bottom */, 0 /* right */]\r\n    ].map(movement),\r\n    [\r\n        [3 /* top */, 2 /* left */],\r\n        [0 /* right */, 1 /* bottom */]\r\n    ].map(movement)\r\n];\r\nexport class TickTackToeTile extends ColorTile {\r\n    constructor(lengthForWin = 3) {\r\n        super(\"white\");\r\n        this.occupied = Turn.NONE;\r\n        this.game = null;\r\n        this.isWinningLine = false;\r\n        this.lengthForWin = lengthForWin;\r\n    }\r\n    render(ctx, t) {\r\n        super.render(ctx, t);\r\n        ctx.fillStyle = turnColor(this.occupied);\r\n        const margin = this.game && ((this.game.won !== Turn.NONE || this.game.blankTiles === 0) && !this.isWinningLine) ? MARGIN * 2 : MARGIN;\r\n        ctx.fillRect(margin, margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);\r\n        if (this.game && t - this.stepTime < 100) {\r\n            ctx.strokeStyle = turnColor(this.game.turn);\r\n            ctx.lineWidth = 5;\r\n            ctx.strokeRect(margin, margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);\r\n        }\r\n    }\r\n    tallyInDir(movmentPattern) {\r\n        let view = this.getView(0);\r\n        for (let i = 0; i < this.lengthForWin; i++) {\r\n            view = movmentPattern(view);\r\n            if (!view || !(view.tile instanceof TickTackToeTile && view.tile.occupied === this.occupied)) {\r\n                return i;\r\n            }\r\n        }\r\n        return this.lengthForWin;\r\n    }\r\n    drawWinningLine(movmentPattern) {\r\n        let view = this.getView(0);\r\n        for (let i = 0; i < this.lengthForWin; i++) {\r\n            view = movmentPattern(view);\r\n            if (!view || !(view.tile instanceof TickTackToeTile && view.tile.occupied === this.occupied)) {\r\n                return;\r\n            }\r\n            view.tile.isWinningLine = true;\r\n        }\r\n    }\r\n    didWin() {\r\n        for (let pair of movementMethods) {\r\n            const n = this.tallyInDir(pair[0]) + this.tallyInDir(pair[1]) + 1;\r\n            if (n >= this.lengthForWin) {\r\n                this.drawWinningLine(pair[0]);\r\n                this.drawWinningLine(pair[1]);\r\n                this.isWinningLine = true;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    linkGame(game = new TickTackToeGame()) {\r\n        if (this.game !== game) {\r\n            this.occupied = Turn.NONE;\r\n            this.isWinningLine = false;\r\n            this.game = game;\r\n            game.blankTiles++;\r\n            this.links.forEach((link) => {\r\n                if (!link)\r\n                    return;\r\n                const tile = link.to;\r\n                if (tile instanceof TickTackToeTile) {\r\n                    tile.linkGame(game);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    stepOn(t) {\r\n        super.stepOn(t);\r\n        if (this.game === null) {\r\n            this.linkGame();\r\n        }\r\n    }\r\n    interact() {\r\n        if (this.game === null || this.game.won !== Turn.NONE || this.game.blankTiles === 0) {\r\n            this.linkGame();\r\n            return;\r\n        }\r\n        if (this.occupied === Turn.NONE) {\r\n            this.occupied = this.game.turn;\r\n            this.game.turn = -this.game.turn;\r\n            this.game.blankTiles--;\r\n            if (this.didWin()) {\r\n                this.game.won = this.occupied;\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tickTackToe/TickTackToeTile.ts\n// module id = 17\n// module chunks = 0","import { RenderableEntity } from \"./RenderableEntity\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nimport { Bolt } from \"./Bolt\";\r\nconst PLAYER_SIZE = 1 / 3;\r\nconst onScreenSize = TILE_SIZE * PLAYER_SIZE;\r\nexport class Player extends RenderableEntity {\r\n    constructor(spawnPt, app) {\r\n        super(PLAYER_SIZE, PLAYER_SIZE, spawnPt);\r\n        this.app = app;\r\n    }\r\n    render(ctx) {\r\n        ctx.fillStyle = \"black\";\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(0, 0, onScreenSize / 2, onScreenSize / 2);\r\n        ctx.fillRect(0, 0, onScreenSize / 2, onScreenSize / 2);\r\n        ctx.strokeRect(0, onScreenSize / 2, onScreenSize, onScreenSize / 2);\r\n        ctx.fillRect(0, onScreenSize / 2, onScreenSize, onScreenSize / 2);\r\n    }\r\n    shoot(dir = this.lastMovementDir) {\r\n        const bolt = new Bolt(dir, this.center.view);\r\n        bolt.move(this.center.pt.x - bolt.center.pt.x, this.center.pt.y - bolt.center.pt.y);\r\n        this.app.addStepable(bolt);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Player.ts\n// module id = 18\n// module chunks = 0","import { ViewCursor } from \"./ViewCursor\";\r\nexport class Entity {\r\n    constructor(width, height, baseTile) {\r\n        this.trackWidth = 2;\r\n        this.trackHeight = 2;\r\n        this.init(width, height, baseTile);\r\n    }\r\n    respawn(view) {\r\n        this.init(this.width, this.height, view);\r\n    }\r\n    init(width, height, baseTile) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if (width > 1 || height > 1)\r\n            throw new RangeError(\"we do not yet suport entities larger than one tile\");\r\n        this.trackingTiles = Array(this.trackWidth);\r\n        this.trackingTilesOld = Array(this.trackWidth);\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            this.trackingTiles[x] = Array(this.trackHeight);\r\n            this.trackingTilesOld[x] = Array(this.trackHeight);\r\n            for (let y = 0; y < this.trackHeight; y++) {\r\n                const trackingPointX = width / (this.trackWidth - 1) * x, trackingPointY = height / (this.trackHeight - 1) * y;\r\n                const tracker = new ViewCursor(baseTile, 0.5 - (width / 2) + trackingPointX, 0.5 - (height / 2) + trackingPointY, trackingPointX, trackingPointY);\r\n                this.trackingTiles[x][y] = tracker;\r\n                this.trackingTilesOld[x][y] = tracker.clone();\r\n            }\r\n        }\r\n        this.center = new ViewCursor(baseTile, 0.5, 0.5, width / 2, height / 2);\r\n        this.centerOld = this.center.clone();\r\n    }\r\n    move(dx, dy) {\r\n        let xSide = dx < 0 ? 2 /* left */ : 0 /* right */;\r\n        let ySide = dy < 0 ? 3 /* top */ : 1 /* bottom */;\r\n        let xLeft = Math.abs(dx);\r\n        let yLeft = Math.abs(dy);\r\n        let xLocked = xLeft === 0;\r\n        let yLocked = yLeft === 0;\r\n        let i = 0;\r\n        this.lastMovementDir = xLeft >= yLeft ? xSide : ySide;\r\n        while ((xLeft > 0 || yLeft > 0) && i < 100) {\r\n            i++;\r\n            if (!xLocked && xLeft > 0) {\r\n                let oPosn = xLeft;\r\n                xLeft = this.tryMove(xSide, xLeft);\r\n                yLocked = yLocked && (oPosn === xLeft || yLeft <= 0);\r\n                xLocked = true;\r\n            }\r\n            if (yLocked)\r\n                break;\r\n            if (!yLocked && yLeft > 0) {\r\n                let oPosn = yLeft;\r\n                yLeft = this.tryMove(ySide, yLeft);\r\n                xLocked = xLocked && (oPosn === yLeft || xLeft <= 0);\r\n                yLocked = true;\r\n            }\r\n            if (xLocked)\r\n                break;\r\n        }\r\n        return xLeft === 0 && yLeft === 0;\r\n    }\r\n    tryMove(side, dist) {\r\n        let distLeft = dist;\r\n        let i = 0;\r\n        while (distLeft > 0 && i < 100) {\r\n            i++;\r\n            //move to edge of tile\r\n            let maxMovement = distLeft;\r\n            for (let x = 0; x < this.trackWidth; x++) {\r\n                for (let y = 0; y < this.trackWidth; y++) {\r\n                    const newDist = this.trackingTiles[x][y].movementUpToEdge(side);\r\n                    if (newDist < maxMovement)\r\n                        maxMovement = newDist;\r\n                }\r\n            }\r\n            const newDist = this.center.movementUpToEdge(side);\r\n            if (newDist < maxMovement)\r\n                maxMovement = newDist;\r\n            if (maxMovement > 0) {\r\n                for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        this.trackingTiles[x][y].moveWithinTile(side, maxMovement);\r\n                    }\r\n                }\r\n                this.center.moveWithinTile(side, maxMovement);\r\n            }\r\n            if (maxMovement === distLeft) {\r\n                distLeft = 0;\r\n                break;\r\n            }\r\n            distLeft -= maxMovement;\r\n            //cross edge\r\n            let crossingValid = true;\r\n            for (let x = 0; x < this.trackWidth; x++) {\r\n                for (let y = 0; y < this.trackWidth; y++) {\r\n                    const thisTracker = this.trackingTiles[x][y];\r\n                    this.trackingTilesOld[x][y].copy(thisTracker);\r\n                    crossingValid = crossingValid && thisTracker.tryCrossEdge(side);\r\n                }\r\n            }\r\n            this.centerOld.copy(this.center);\r\n            crossingValid = crossingValid && this.center.tryCrossEdge(side);\r\n            if (crossingValid) {\r\n                outer: for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        const tgtView = this.trackingTiles[x][y].view;\r\n                        if (x !== 0) {\r\n                            const leftView = this.trackingTiles[x - 1][y].view;\r\n                            crossingValid = crossingValid && (tgtView === leftView || tgtView.getNeighbor(2 /* left */) === leftView);\r\n                        }\r\n                        if (y !== 0) {\r\n                            const topView = this.trackingTiles[x][y - 1].view;\r\n                            crossingValid = crossingValid && (tgtView === topView || tgtView.getNeighbor(3 /* top */) === topView);\r\n                        }\r\n                        if (!crossingValid) {\r\n                            break outer;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!crossingValid) {\r\n                for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        this.trackingTiles[x][y].copy(this.trackingTilesOld[x][y]);\r\n                    }\r\n                }\r\n                this.center.copy(this.centerOld);\r\n                break;\r\n            }\r\n        }\r\n        return distLeft;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Entity.ts\n// module id = 19\n// module chunks = 0","import { Cursor } from \"./Cursor\";\r\nexport class ViewCursor {\r\n    constructor(view, x, y, onEntityX, onEntityY) {\r\n        this.view = view;\r\n        this.pt = new Cursor({ x, y });\r\n        this.onEntityX = onEntityX;\r\n        this.onEntityY = onEntityY;\r\n    }\r\n    movementUpToEdge(dir) {\r\n        switch (dir) {\r\n            case 2 /* left */: return this.pt.x;\r\n            case 0 /* right */: return 1 - this.pt.x;\r\n            case 3 /* top */: return this.pt.y;\r\n            case 1 /* bottom */: return 1 - this.pt.y;\r\n        }\r\n    }\r\n    moveWithinTile(dir, dist) {\r\n        this.pt.step(dir, dist);\r\n    }\r\n    tryCrossEdge(dir) {\r\n        if (this.movementUpToEdge(dir) === 0) {\r\n            const next = this.view.getNeighbor(dir);\r\n            if (!next)\r\n                return false;\r\n            this.pt.step(dir, -1);\r\n            this.view = next;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    copy(other) {\r\n        this.pt = other.pt.fork();\r\n        this.view = other.view;\r\n        this.onEntityY = other.onEntityY;\r\n        this.onEntityX = other.onEntityX;\r\n    }\r\n    clone() {\r\n        return new ViewCursor(this.view, this.pt.x, this.pt.y, this.onEntityX, this.onEntityY);\r\n    }\r\n    move(dx, dy) {\r\n        let xSide = dx < 0 ? 2 /* left */ : 0 /* right */;\r\n        let ySide = dy < 0 ? 3 /* top */ : 1 /* bottom */;\r\n        let xLeft = Math.abs(dx);\r\n        let yLeft = Math.abs(dy);\r\n        let xLocked = xLeft === 0;\r\n        let yLocked = yLeft === 0;\r\n        let i = 0;\r\n        while ((xLeft > 0 || yLeft > 0) && i < 100) {\r\n            i++;\r\n            if (!xLocked && xLeft > 0) {\r\n                let oPosn = xLeft;\r\n                xLeft = this.tryMove(xSide, xLeft);\r\n                yLocked = yLocked && (oPosn === xLeft || yLeft <= 0);\r\n                xLocked = true;\r\n            }\r\n            if (yLocked)\r\n                break;\r\n            if (!yLocked && yLeft > 0) {\r\n                let oPosn = yLeft;\r\n                yLeft = this.tryMove(ySide, yLeft);\r\n                xLocked = xLocked && (oPosn === yLeft || xLeft <= 0);\r\n                yLocked = true;\r\n            }\r\n            if (xLocked)\r\n                break;\r\n        }\r\n        if (xLeft !== 0 && yLeft !== 0)\r\n            console.log(xLeft, yLeft);\r\n        return xLeft === 0 && yLeft === 0;\r\n    }\r\n    tryMove(dir, dist) {\r\n        let i = 0;\r\n        let left = dist;\r\n        while (left > 0 && i < 100) {\r\n            i--;\r\n            const canMove = Math.min(this.movementUpToEdge(dir), left);\r\n            if (canMove > 0) {\r\n                this.moveWithinTile(dir, canMove);\r\n            }\r\n            left -= canMove;\r\n            if (left === canMove)\r\n                break;\r\n            if (!this.tryCrossEdge(dir))\r\n                break;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ViewCursor.ts\n// module id = 20\n// module chunks = 0","import { RenderableEntity } from \"./RenderableEntity\";\r\nimport { getDelta } from \"./Side\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst BOLT_SPEED = 10 / 1000;\r\nexport class Bolt extends RenderableEntity {\r\n    constructor(dir, tile) {\r\n        super(dir & 1 ? 1 / 6 : 5 / 6, dir & 1 ? 5 / 6 : 1 / 6, tile);\r\n        this.age = 0;\r\n        this.dir = dir;\r\n        this.dirPt = getDelta(dir);\r\n    }\r\n    step(dt) {\r\n        this.age += dt;\r\n        const hitWall = !this.move(this.dirPt.x * BOLT_SPEED * dt, this.dirPt.y * BOLT_SPEED * dt);\r\n        if (hitWall) {\r\n            this.age += dt * 10;\r\n        }\r\n        const stayAlive = this.age < 10000;\r\n        if (!stayAlive)\r\n            this.kill();\r\n        return stayAlive;\r\n    }\r\n    render(ctx) {\r\n        ctx.lineWidth = 2;\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(0, 0, this.width * TILE_SIZE, this.height * TILE_SIZE);\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.strokeRect(0, 0, this.width * TILE_SIZE, this.height * TILE_SIZE);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Bolt.ts\n// module id = 21\n// module chunks = 0"],"sourceRoot":""}