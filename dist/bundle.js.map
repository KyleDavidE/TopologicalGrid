{"version":3,"sources":["webpack:///webpack/bootstrap 29b563679535f000e5f0","webpack:///./src/opts.ts","webpack:///./src/Side.ts","webpack:///./src/DirMtx.ts","webpack:///./src/Cursor.ts","webpack:///./src/Tile.ts","webpack:///./src/ColorTile.ts","webpack:///./src/compose.ts","webpack:///./src/RenderableEntity.ts","webpack:///./src/index.ts","webpack:///./src/App.ts","webpack:///./src/Renderer.ts","webpack:///./src/Projector.ts","webpack:///./src/LinearObjectPool.ts","webpack:///./src/testLevels.ts","webpack:///./src/TileGrid.ts","webpack:///./src/SideReference.ts","webpack:///./src/TileView.ts","webpack:///./src/tickTackToe/TickTackToeTile.ts","webpack:///./src/autoWall.ts","webpack:///./src/WallTile.ts","webpack:///./src/Player.ts","webpack:///./src/Entity.ts","webpack:///./src/ViewCursor.ts","webpack:///./src/Bolt.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","side","deltas","Array","from","length","map","_","delta","y","x","makeDelta","reverseSide","base","args","reduce","dirMtxProductImpl","mtx","dir","det","dirMtxApply","vec","left","right","primary","secondary","window","debug","console","log","__WEBPACK_IMPORTED_MODULE_0__Side__","Cursor","[object Object]","this","mag","dx","dy","nextId","links","id","entities","Set","walkable","tileViews","propertyDominance","Math","random","__WEBPACK_IMPORTED_MODULE_2__TileView__","reciprocate","link","to","unlink","destSide","fromSide","toTile","toSide","__WEBPACK_IMPORTED_MODULE_1__Side__","reflect","addReverse","__WEBPACK_IMPORTED_MODULE_0__SideReference__","fromOpts","onLinked","ctx","t","playerDist","playerShear","loadTimer","entity","add","__WEBPACK_IMPORTED_MODULE_0__Tile__","color","super","stepTime","noiseLevel","render","globalAlpha","pow","fillStyle","fillRect","__WEBPACK_IMPORTED_MODULE_1__opts__","strokeStyle","fns","leftFn","rightFn","__WEBPACK_IMPORTED_MODULE_0__Entity__","width","height","baseTile","gone","trackingTiles","register","out","move","tile","respawn","trackWidth","view","track","renderer","renderHistory","rh","tracker","renderKey","orientation","pt","onEntityX","onEntityY","has","save","applyOrientation","__WEBPACK_IMPORTED_MODULE_1__DirMtx__","translate","__WEBPACK_IMPORTED_MODULE_2__opts__","restore","app","level","__WEBPACK_IMPORTED_MODULE_1__testLevels__","movementKeys","w","a","shootKeys","k","j","PLAYER_SPEED","stepables","vel","__WEBPACK_IMPORTED_MODULE_2__Cursor__","monitorKeys","q","interactLock","currentWarp","dest","getView","mockPlayer","__WEBPACK_IMPORTED_MODULE_3__Player__","progress","explodeLevel","explodeVelocity","can","document","getElementById","__WEBPACK_IMPORTED_MODULE_0__Renderer__","requestAnimationFrame","nt","tick","onkeydown","e","keyDown","onkeyup","keyUp","ondblclick","requestPointerLock","allEvt","onmousemove","pointerLockElement","abs","movementX","movementY","killWarp","player","__WEBPACK_IMPORTED_MODULE_4__opts__","getNeighbor","cam","center","clone","dt","wat","innerWidth","innerHeight","tryMove","stepable","step","delete","ctr","locCam","copy","stepOn","watNumber","key","interact","performance","now","shoot","shiftKey","startWarpHome","kill","viewTile","every","row","DEBUG","SUPERDebug","TARGET_SIZE","projector","__WEBPACK_IMPORTED_MODULE_0__Projector__","getContext","root","offsetX","offsetY","displayOffsetX","displayOffsetY","warpDest","warpProg","explode","scale","max","items","project","r","sqrt","item","beginPath","rect","clip","moveTo","cos","minTheta","sin","lineTo","maxTheta","stroke","anglesLength","fromAng","angles","toAng","sf","lineWidth","translateX","translateY","leftOrientation","topOrientation","cornerDist","cornerShear","fillText","entitiesInit","isOnTile","renderInContext","doTranslate","rotate","PI","reduceAngle","angle","b","reduceAngleCentered","FUDGE_THETA","tmp","ANGLE_RANGE","ProjectionPath","Float64Array","isRoot","rootAngleMin","rootAngleMax","centerAngle","atan2","isOpen","ang","Infinity","ox","oy","theta","addRangeImpl","startIndex","endIndex","startIsOutside","endIsOutside","lengthChange","copyWithin","EDGE_GLITCH_REDUCTION_DIST","lookup","Map","projectionPathPool","__WEBPACK_IMPORTED_MODULE_0__LinearObjectPool__","renderRadiusX","renderRadiusY","displayOffestY","warpProgress","done","que","clear","addRoot","rootPath","pop","init","set","push","angAdd","shift","considerItem","warn","values","considerSide","axis","offsetZ","nextTile","nextX","nextY","lineZ","topU","bottomU","makeAng","u","projectAng","slopeUZ","tan","colU","newItem","considerAngleRange","newFromAng","newToAng","addRange","foldAngleRange","mid","makeT","size","usedIndex","usedSize","clean","data","makeHubRoom","grid1","__WEBPACK_IMPORTED_MODULE_0__TileGrid__","solidColorTiles","grid2","portSpace","center1","center2","bridge","reverse","__WEBPACK_IMPORTED_MODULE_1__ColorTile__","getReference","ballPort","grid","dynamicColor","mirror","cardinal","isolate","shortWay","S","fastLane","longGrid","shortLength","rain","shortGrid","targ","fastLane2","colorTile","threeTurns","branches","addSide","inner","north","east","west","floor","branches2","tickTackToeLayer","tickTackToeDonut","tickTackToeKlign","tickTackToeMirror","tickTackToeDonutOffset","mobius","len","ot","nextDir","spiral","edgeLength","edge","wheel","__WEBPACK_IMPORTED_MODULE_4__autoWall__","xc","yc","next","h","offset","__WEBPACK_IMPORTED_MODULE_2__compose__","__WEBPACK_IMPORTED_MODULE_3__tickTackToe_TickTackToeTile__","W","H","worlds","forEach","reduceRight","rightTile","rightBridge","worldRoot","hubTile","hubBridge","leftBridge","leftTile","layers","getTiles","tiles","SideReference","__WEBPACK_IMPORTED_MODULE_0__DirMtx__","WeakMap","TileView","computeSide","Turn","turnColor","turn","RED","BLACK","TickTackToeGame","won","NONE","blankTiles","MARGIN","singleStepMovement","movement","dirs","movementMethods","TickTackToeTile","__WEBPACK_IMPORTED_MODULE_0__ColorTile__","lengthForWin","occupied","game","isWinningLine","margin","strokeRect","movmentPattern","pair","tallyInDir","drawWinningLine","linkGame","didWin","time","explored","wallsToLink","__WEBPACK_IMPORTED_MODULE_0__WallTile__","timeEnd","wall","nextBase","targWall","wallShade","PERSPECTIVE","fill","PLAYER_SIZE","onScreenSize","__WEBPACK_IMPORTED_MODULE_0__RenderableEntity__","spawnPt","lastMovementDir","bolt","__WEBPACK_IMPORTED_MODULE_2__Bolt__","addStepable","trackHeight","RangeError","trackingTilesOld","trackingPointX","trackingPointY","__WEBPACK_IMPORTED_MODULE_0__ViewCursor__","centerOld","xSide","ySide","xLeft","yLeft","xLocked","yLocked","oPosn","dist","distLeft","maxMovement","newDist","movementUpToEdge","moveWithinTile","crossingValid","thisTracker","tryCrossEdge","outer","tgtView","leftView","topView","ViewCursor","__WEBPACK_IMPORTED_MODULE_0__Cursor__","other","fork","canMove","min","BOLT_SPEED","age","dirPt","stayAlive"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 29b563679535f000e5f0","export const TILE_SIZE = 100;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/opts.ts\n// module id = 0\n// module chunks = 0","export const directions = [0 /* right */, 1 /* bottom */, 2 /* left */, 3 /* top */];\r\nfunction makeDelta(i) {\r\n    const delta = i > 1 ? -1 : 1;\r\n    if (i & 1) {\r\n        return { y: delta, x: 0 };\r\n    }\r\n    else {\r\n        return { x: delta, y: 0 };\r\n    }\r\n}\r\nconst deltas = Array.from({ length: 4 }).map((_, i) => makeDelta(i));\r\nexport function getDelta(side) {\r\n    return deltas[side];\r\n}\r\nexport function reverseSide(side) {\r\n    return side ^ 2;\r\n}\r\nexport function getPerpendicularCW(side) {\r\n    return (side + 1) & 3;\r\n}\r\nexport function getPerpendicularCCW(side) {\r\n    return (side + 3) & 3;\r\n}\r\nexport function makePositive(side) {\r\n    return side & 1;\r\n}\r\nexport function getTravel(side) {\r\n    return makePositive(getPerpendicularCW(side));\r\n}\r\nexport function rotate(side, by) {\r\n    return (side + by) & 3;\r\n}\r\nexport function reflect(side, { x, y }) {\r\n    return (side & 1 ? y : x) ? reverseSide(side) : side;\r\n}\r\nexport function invertReflection({ x, y }) {\r\n    return { x: !x, y: !y };\r\n}\r\nexport function mergeReflections({ x, y }, { x: x2, y: y2 }) {\r\n    return {\r\n        x: x !== x2,\r\n        y: y !== y2\r\n    };\r\n}\r\nexport function getOffside(posn) {\r\n    if (posn.x > 1)\r\n        return 0 /* right */;\r\n    if (posn.x < -1)\r\n        return 2 /* left */;\r\n    if (posn.y > 1)\r\n        return 1 /* bottom */;\r\n    if (posn.y < -1)\r\n        return 3 /* top */;\r\n    return -1;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Side.ts\n// module id = 1\n// module chunks = 0","import { getPerpendicularCCW } from './Side';\r\nimport { Cursor } from './Cursor';\r\n// function dirMtxApply(mtx: DirMTX, vec: Side): Side{\r\n//     return (vec & 1 ? ((mtx & 0b11) + ((mtx & 0b100) ? 1 : -1) ) & 0b11 : mtx & 0b11) ^ (vec & 0b10);\r\n// }\r\nexport function dirMtxApply(mtx, vec) {\r\n    return ((mtx & 0b11) + ((mtx & 0b100) ? -vec : vec)) & 0b11;\r\n}\r\nexport function dirMtxProductImpl(left, right) {\r\n    const primary = dirMtxApply(left, dirMtxApply(right, 0));\r\n    const secondary = dirMtxApply(left, dirMtxApply(right, 1));\r\n    if (window.debug)\r\n        console.log(primary, secondary);\r\n    return primary | (getPerpendicularCCW(primary) === secondary ? 0b100 : 0);\r\n}\r\nexport function dirMtxProduct(base, ...args) {\r\n    return args.reduce(dirMtxProductImpl, base);\r\n}\r\nexport function dirMtxInverse(mtx) {\r\n    return (mtx & 0b100) ? mtx : (-mtx) & 0b11;\r\n}\r\nexport function makeDirMtx(dir, det) {\r\n    return det ? (dir & 0b11) | 0b100 : dir & 0b11;\r\n}\r\nexport function dirMtxApplyPt(mtx, pt) {\r\n    return new Cursor({ x: 0, y: 0 }).step(dirMtxApply(mtx, 0 /* right */), pt.x).step(dirMtxApply(mtx, 1 /* bottom */), pt.y);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/DirMtx.ts\n// module id = 2\n// module chunks = 0","import { getDelta } from \"./Side\";\r\nexport class Cursor {\r\n    constructor(p) {\r\n        this.x = p.x;\r\n        this.y = p.y;\r\n    }\r\n    step(side, mag = 1) {\r\n        const { x: dx, y: dy } = getDelta(side);\r\n        this.x += dx * mag;\r\n        this.y += dy * mag;\r\n        return this;\r\n    }\r\n    fork() {\r\n        return new Cursor(this);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Cursor.ts\n// module id = 3\n// module chunks = 0","import { SideReference } from './SideReference';\r\nimport { reverseSide } from './Side';\r\nimport { TileView } from './TileView';\r\nlet nextId = 0;\r\nexport class Tile {\r\n    constructor() {\r\n        this.links = [null, null, null, null];\r\n        this.id = nextId++;\r\n        this.entities = new Set();\r\n        this.walkable = true;\r\n        this.tileViews = Array(8);\r\n        this.propertyDominance = Math.random();\r\n        for (let i = 0; i < 8; i++) {\r\n            this.tileViews[i] = new TileView(this, i);\r\n        }\r\n    }\r\n    getReference(i) {\r\n        return this.links[i];\r\n    }\r\n    unlink(i, reciprocate = true) {\r\n        if (this.links[i]) {\r\n            const link = this.links[i];\r\n            if (reciprocate) {\r\n                link.to.unlink(link.destSide, false);\r\n            }\r\n            this.links[i] = null;\r\n        }\r\n    }\r\n    link(fromSide, toTile, toSide = reverseSide(fromSide), { reflect = false, addReverse = true } = {}) {\r\n        this.unlink(fromSide);\r\n        this.links[fromSide] = SideReference.fromOpts(toTile, fromSide, toSide, reflect);\r\n        if (addReverse) {\r\n            toTile.link(toSide, this, fromSide, {\r\n                addReverse: false,\r\n                reflect\r\n            });\r\n        }\r\n        this.onLinked(this.links[fromSide]);\r\n    }\r\n    onLinked(side) {\r\n    }\r\n    getView(mtx) {\r\n        return this.tileViews[mtx];\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        this.loadTimer = t;\r\n    }\r\n    isolate() {\r\n        for (let i = 0; i < 4; i++) {\r\n            this.unlink(i);\r\n        }\r\n    }\r\n    stepOn(t) {\r\n    }\r\n    interact(t) {\r\n    }\r\n    track(entity) {\r\n        this.entities.add(entity);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Tile.ts\n// module id = 4\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nexport class ColorTile extends Tile {\r\n    constructor(color) {\r\n        super();\r\n        this.stepTime = 0;\r\n        this.color = color;\r\n        this.noiseLevel = 1 - Math.random() * 0.2;\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        super.render(ctx, t, playerDist, playerShear);\r\n        ctx.globalAlpha = (1 - Math.pow(2, (this.stepTime - t) / 1000) / 3) * this.noiseLevel;\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\r\n        ctx.globalAlpha = 1;\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n    stepOn(t) {\r\n        this.stepTime = t;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ColorTile.ts\n// module id = 5\n// module chunks = 0","export function strictCompose(fns) {\r\n    return fns.reduce((leftFn, rightFn) => (x) => leftFn(rightFn(x)), x => x);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/compose.ts\n// module id = 6\n// module chunks = 0","import { Entity } from \"./Entity\";\r\nimport { dirMtxInverse } from \"./DirMtx\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nexport class RenderableEntity extends Entity {\r\n    constructor(width, height, baseTile) {\r\n        super(width, height, baseTile);\r\n        this.gone = false;\r\n        console.log(this.trackingTiles);\r\n        this.register();\r\n    }\r\n    move(dx, dy) {\r\n        const out = super.move(dx, dy);\r\n        this.register();\r\n        return out;\r\n    }\r\n    respawn(tile) {\r\n        super.respawn(tile);\r\n        this.register();\r\n    }\r\n    render(ctx) {\r\n    }\r\n    kill() {\r\n        this.gone = true;\r\n    }\r\n    isOnTile(tile) {\r\n        if (this.gone)\r\n            return false;\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                if (this.trackingTiles[x][y].view.tile.id === tile.id) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    register() {\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                this.trackingTiles[x][y].view.track(this);\r\n            }\r\n        }\r\n    }\r\n    renderInContext(renderer, tile) {\r\n        const renderHistory = new Set();\r\n        window.rh = renderHistory;\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                const tracker = this.trackingTiles[x][y];\r\n                if (tracker.view.tile === tile) {\r\n                    const renderKey = `${tracker.view.orientation}/${tracker.pt.x - tracker.onEntityX}/${tracker.pt.y - tracker.onEntityY}`;\r\n                    if (!renderHistory.has(renderKey)) {\r\n                        renderHistory.add(renderKey);\r\n                        renderer.ctx.save();\r\n                        renderer.applyOrientation(dirMtxInverse(tracker.view.orientation));\r\n                        renderer.ctx.translate((tracker.pt.x - tracker.onEntityX) * TILE_SIZE, (tracker.pt.y - tracker.onEntityY) * TILE_SIZE);\r\n                        this.render(renderer.ctx);\r\n                        renderer.ctx.restore();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RenderableEntity.ts\n// module id = 7\n// module chunks = 0","import { App } from \"./App\";\r\nconst app = new App();\r\nwindow.app = app;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 8\n// module chunks = 0","import { Renderer } from \"./Renderer\";\r\nimport * as testLevels from './testLevels';\r\nimport { Cursor } from \"./Cursor\";\r\nimport { Player } from \"./Player\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst level = testLevels.hubRoom();\r\nconst movementKeys = {\r\n    w: 3 /* top */,\r\n    a: 2 /* left */,\r\n    s: 1 /* bottom */,\r\n    d: 0 /* right */\r\n};\r\nconst shootKeys = {\r\n    i: 3 /* top */,\r\n    l: 0 /* right */,\r\n    k: 1 /* bottom */,\r\n    j: 2 /* left */\r\n};\r\nconst PLAYER_SPEED = 5 / 1000;\r\nexport class App {\r\n    constructor() {\r\n        this.stepables = new Set();\r\n        this.vel = new Cursor({ x: 0, y: 0 });\r\n        this.monitorKeys = {\r\n            w: false,\r\n            a: false,\r\n            s: false,\r\n            d: false,\r\n            q: false\r\n        };\r\n        this.interactLock = false;\r\n        this.currentWarp = {\r\n            dest: level.getView(0),\r\n            mockPlayer: new Player(level.getView(0), null),\r\n            progress: 0.5\r\n        };\r\n        this.explodeLevel = 0;\r\n        this.explodeVelocity = 0;\r\n        this.can = document.getElementById(\"can\");\r\n        this.renderer = new Renderer(this.can);\r\n        requestAnimationFrame(t => requestAnimationFrame((nt) => this.tick(nt, nt - t, Math.random())));\r\n        document.onkeydown = (e) => {\r\n            this.keyDown(e);\r\n        };\r\n        document.onkeyup = (e) => {\r\n            this.keyUp(e);\r\n        };\r\n        this.can.ondblclick = (e) => {\r\n            this.can.requestPointerLock();\r\n            this.allEvt(e);\r\n        };\r\n        this.can.onmousemove = (e) => {\r\n            if (document.pointerLockElement === this.can) {\r\n                if (Math.abs(e.movementX) < 200 && Math.abs(e.movementY) < 200) {\r\n                    this.killWarp();\r\n                    this.player.move(e.movementX / TILE_SIZE, e.movementY / TILE_SIZE);\r\n                }\r\n            }\r\n            this.allEvt(e);\r\n        };\r\n        this.player = new Player(level.getView(0).getNeighbor(0 /* right */), this);\r\n        this.cam = this.player.center.clone();\r\n    }\r\n    tick(t, dt, wat) {\r\n        if (this.can.width !== innerWidth || this.can.height !== innerHeight) {\r\n            this.can.width = innerWidth;\r\n            this.can.height = innerHeight;\r\n        }\r\n        this.tryMove(dt);\r\n        for (let stepable of this.stepables) {\r\n            if (!stepable.step(dt)) {\r\n                this.stepables.delete(stepable);\r\n            }\r\n        }\r\n        if (this.currentWarp) {\r\n            this.currentWarp.progress += dt / 1000;\r\n            if (this.currentWarp.progress > 1) {\r\n                this.player.respawn(this.currentWarp.dest);\r\n                this.player.move(this.currentWarp.mockPlayer.center.pt.x - 0.5, this.currentWarp.mockPlayer.center.pt.y - 0.5);\r\n                this.killWarp();\r\n            }\r\n        }\r\n        const ctr = this.locCam || this.player.center;\r\n        this.cam.copy(ctr);\r\n        const offsetX = 0;\r\n        const offsetY = 0;\r\n        this.explodeVelocity -= (this.monitorKeys.q ? -1 : 1) * dt / 1000 / 1000 * 5;\r\n        this.explodeLevel += this.explodeVelocity * dt;\r\n        if (this.explodeLevel > 0) {\r\n            // this.explodeVelocity = \r\n        }\r\n        else if (this.explodeLevel < 0) {\r\n            this.explodeVelocity = 0;\r\n            this.explodeLevel = 0;\r\n        }\r\n        ctr.view.stepOn(t);\r\n        if (!this.cam.move(offsetX, offsetY)) {\r\n            console.log(\"wat\");\r\n        }\r\n        this.renderer.render(this.cam.view, this.cam.pt.x, this.cam.pt.y, t, offsetX, offsetY, this.currentWarp ? this.currentWarp.dest : null, this.currentWarp ? this.currentWarp.progress : 0, 2 ** this.explodeLevel);\r\n        if (this.watNumber !== wat)\r\n            console.log('wat');\r\n        this.watNumber = wat;\r\n        requestAnimationFrame((nt) => this.tick(nt, nt - t, wat));\r\n    }\r\n    keyDown(e) {\r\n        if (e.key in this.monitorKeys) {\r\n            this.monitorKeys[e.key] = true;\r\n        }\r\n        if (e.key === \"e\" && !this.interactLock) {\r\n            this.interactLock = true;\r\n            this.player.center.view.interact(performance.now());\r\n        }\r\n        if (e.key in shootKeys) {\r\n            this.player.shoot(shootKeys[e.key]);\r\n        }\r\n        this.allEvt(e);\r\n    }\r\n    allEvt(e) {\r\n        if (e.shiftKey && !this.locCam) {\r\n            this.locCam = this.player.center.clone();\r\n        }\r\n        if (!e.shiftKey) {\r\n            this.locCam = null;\r\n        }\r\n    }\r\n    keyUp(e) {\r\n        if (e.key in this.monitorKeys) {\r\n            this.monitorKeys[e.key] = false;\r\n        }\r\n        if (e.key === \"e\") {\r\n            this.interactLock = false;\r\n        }\r\n        if (e.key === \"h\") {\r\n            this.startWarpHome();\r\n            // this.player.respawn(level.getView(0));\r\n        }\r\n        this.allEvt(e);\r\n    }\r\n    tryMove(dt) {\r\n        this.vel.x = 0;\r\n        this.vel.y = 0;\r\n        for (let key in movementKeys) {\r\n            if (this.monitorKeys[key]) {\r\n                this.vel.step(movementKeys[key], PLAYER_SPEED * dt);\r\n            }\r\n        }\r\n        if (this.vel.x !== 0 || this.vel.y !== 0) {\r\n            this.killWarp();\r\n            this.player.move(this.vel.x, this.vel.y);\r\n        }\r\n        // if(this.posn.x > 1){\r\n        //     if(!this.tryStep(Side.right)){\r\n        //         this.posn.x = 1\r\n        //     }\r\n        // }\r\n        // if (this.posn.y > 1) {\r\n        //     if (!this.tryStep(Side.bottom)) {\r\n        //         this.posn.y = 1;\r\n        //     }\r\n        // }\r\n        // if (this.posn.x < 0) {\r\n        //     if (!this.tryStep(Side.left)) {\r\n        //         this.posn.x = 0;\r\n        //     }\r\n        // }\r\n        // if (this.posn.y < 0) {\r\n        //     if (!this.tryStep(Side.top)) {\r\n        //         this.posn.y = 0;\r\n        //     }\r\n        // }\r\n    }\r\n    // tryStep(dir: Side){\r\n    //     if(this.view.getNeighbor(dir)){\r\n    //         this.view = this.view.getNeighbor(dir);\r\n    //         this.posn.step(dir,-1);\r\n    //         return true;\r\n    //     }\r\n    //     return false;\r\n    // }\r\n    killWarp() {\r\n        if (this.explodeVelocity > -1 / 100)\r\n            this.explodeVelocity = -1 / 100;\r\n        if (this.currentWarp) {\r\n            this.currentWarp.progress = 0;\r\n            this.currentWarp.mockPlayer.kill();\r\n            this.currentWarp = null;\r\n        }\r\n    }\r\n    startWarpHome() {\r\n        if (!this.currentWarp) {\r\n            const viewTile = this.player.center.view;\r\n            const isOnTile = this.player.trackingTiles.every((row) => row.every((tracker) => !tracker || tracker.view === viewTile));\r\n            if (!isOnTile)\r\n                return;\r\n            const dest = level.getView(0);\r\n            this.currentWarp = {\r\n                dest: dest,\r\n                mockPlayer: new Player(dest, this),\r\n                progress: 0\r\n            };\r\n            this.currentWarp.mockPlayer.move(this.player.center.pt.x - 0.5, this.player.center.pt.y - 0.5);\r\n        }\r\n    }\r\n    addStepable(stepable) {\r\n        this.stepables.add(stepable);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.ts\n// module id = 9\n// module chunks = 0","import { Projector } from \"./Projector\";\r\nimport { dirMtxApply } from \"./DirMtx\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst debugColors = ['red', 'green', 'blue', 'cyan', 'orange'];\r\nfunction debugColor() {\r\n    return debugColors[(Math.random() * debugColors.length) | 0];\r\n}\r\nconst DEBUG = false;\r\nconst SUPERDebug = false;\r\nconst TARGET_SIZE = 12;\r\n// const DEBUGMAP = {7:true, 3:true};\r\nexport class Renderer {\r\n    constructor(can) {\r\n        this.projector = new Projector();\r\n        this.can = can;\r\n        this.ctx = can.getContext('2d');\r\n    }\r\n    render(root, offsetX, offsetY, t, displayOffsetX, displayOffsetY, warpDest, warpProg, explode = 1) {\r\n        const scale = this.scale = 1 / Math.max(TILE_SIZE * TARGET_SIZE / this.can.width, TILE_SIZE * TARGET_SIZE / this.can.height);\r\n        const items = this.projector.project(root, offsetX, offsetY, this.can.width / TILE_SIZE / 2 / scale, this.can.height / TILE_SIZE / 2 / scale, displayOffsetX, displayOffsetY, warpDest, warpProg);\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.fillRect(0, 0, this.can.width, this.can.height);\r\n        this.ctx.save();\r\n        this.ctx.translate(this.can.width / 2, this.can.height / 2);\r\n        this.ctx.scale(scale, scale);\r\n        this.ctx.translate((displayOffsetX * TILE_SIZE), (displayOffsetY * TILE_SIZE));\r\n        // this.ctx.scale(TILE_SIZE, TILE_SIZE);\r\n        const r = Math.sqrt((this.can.width + TILE_SIZE) ** 2 +\r\n            (this.can.height + TILE_SIZE) ** 2);\r\n        for (let item of items) {\r\n            // if (DEBUG) console.log(item);\r\n            this.ctx.save();\r\n            if (SUPERDebug) {\r\n                if ((item.x !== 0 || item.y !== -2)) {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.rect((item.x - offsetX) * TILE_SIZE, (item.y - offsetY) * TILE_SIZE, TILE_SIZE, TILE_SIZE);\r\n                    this.ctx.clip();\r\n                }\r\n                else {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.moveTo(1000 * Math.cos(item.minTheta), 1000 * Math.sin(item.minTheta));\r\n                    this.ctx.lineTo(0, 0);\r\n                    this.ctx.lineTo(1000 * Math.cos(item.maxTheta), 1000 * Math.sin(item.maxTheta));\r\n                    this.ctx.strokeStyle = 'orange';\r\n                    this.ctx.stroke();\r\n                }\r\n            }\r\n            if (item.anglesLength !== 2) {\r\n                this.ctx.beginPath();\r\n                for (let i = 0; i < item.anglesLength; i += 2) {\r\n                    const fromAng = item.angles[i];\r\n                    const toAng = item.angles[i + 1];\r\n                    if (fromAng === toAng)\r\n                        continue;\r\n                    const sf = Math.abs(1 / Math.cos((fromAng - toAng) / 2));\r\n                    this.ctx.moveTo(0, 0);\r\n                    this.ctx.lineTo(Math.cos(fromAng) * r * sf, Math.sin(fromAng) * r * sf);\r\n                    // this.ctx.arc(0, 0, r * TILE_SIZE, fromAng, toAng);\r\n                    this.ctx.lineTo(Math.cos(toAng) * r * sf, Math.sin(toAng) * r * sf);\r\n                    this.ctx.lineTo(0, 0);\r\n                }\r\n                if (DEBUG) {\r\n                    this.ctx.lineWidth = 1;\r\n                    this.ctx.strokeStyle = \"pink\";\r\n                    this.ctx.stroke();\r\n                }\r\n                this.ctx.clip();\r\n            }\r\n            const translateX = ((item.x * explode - offsetX) * TILE_SIZE);\r\n            const translateY = ((item.y * explode - offsetY) * TILE_SIZE);\r\n            this.ctx.translate(translateX, translateY);\r\n            this.applyOrientation(item.view.orientation);\r\n            const leftOrientation = dirMtxApply(item.view.orientation, 2 /* left */);\r\n            const topOrientation = dirMtxApply(item.view.orientation, 3 /* top */);\r\n            // this.ctx.beginPath();\r\n            // this.ctx.rect(0, 0, 1, 1);\r\n            // this.ctx.clip();\r\n            const cornerDist = (leftOrientation & 0b1 ? translateY : translateX);\r\n            const cornerShear = (topOrientation & 0b1 ? translateY : translateX);\r\n            item.view.tile.render(this.ctx, t, leftOrientation & 0b10 ? cornerDist : (-TILE_SIZE - cornerDist), topOrientation & 0b10 ? cornerShear : (-TILE_SIZE - cornerShear));\r\n            if (DEBUG) {\r\n                this.ctx.fillStyle = \"black\";\r\n                this.ctx.fillText(`${item.view.id}`, 10, 10);\r\n            }\r\n            let entitiesInit = false;\r\n            const tile = item.view.tile;\r\n            for (let entity of item.view.tile.entities) {\r\n                const isOnTile = entity.isOnTile(item.view.tile);\r\n                if (!isOnTile) {\r\n                    tile.entities.delete(entity);\r\n                }\r\n                else {\r\n                    if (!entitiesInit) {\r\n                        this.ctx.beginPath();\r\n                        this.ctx.rect(0, 0, TILE_SIZE, TILE_SIZE);\r\n                        this.ctx.clip();\r\n                        entitiesInit = true;\r\n                    }\r\n                    entity.renderInContext(this, item.view.tile);\r\n                }\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n        // this.ctx.beginPath();\r\n        // this.ctx.fillStyle = 'black';\r\n        // this.ctx.arc(0, 0, TILE_SIZE / 3, 0, Math.PI * 2);\r\n        // this.ctx.fill();\r\n        this.ctx.restore();\r\n        // this.ctx.beginPath();\r\n        // for (let x = (this.can.width / 2 - offsetX * TILE_SIZE) % TILE_SIZE - TILE_SIZE; x < this.can.width; x += TILE_SIZE) {\r\n        //     this.ctx.moveTo(x, 0);\r\n        //     this.ctx.lineTo(x, this.can.height);\r\n        // }\r\n        // for (let y = (this.can.height / 2 - offsetY * TILE_SIZE) % TILE_SIZE - TILE_SIZE; y < this.can.height; y += TILE_SIZE) {\r\n        //     this.ctx.moveTo(0, y);\r\n        //     this.ctx.lineTo(this.can.width, y);\r\n        // }    \r\n        // this.ctx.strokeStyle = 'rgba(255,255,255,1)';\r\n        // this.ctx.lineWidth = 1;\r\n        // this.ctx.stroke();\r\n    }\r\n    applyOrientation(orientation, doTranslate = true) {\r\n        const { ctx } = this;\r\n        if (doTranslate)\r\n            this.ctx.translate(0.5 * TILE_SIZE, 0.5 * TILE_SIZE);\r\n        ctx.rotate((orientation & 0b11) * Math.PI / 2);\r\n        if (orientation & 0b100)\r\n            ctx.scale(1, -1);\r\n        if (doTranslate)\r\n            this.ctx.translate(-0.5 * TILE_SIZE, -0.5 * TILE_SIZE);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Renderer.ts\n// module id = 10\n// module chunks = 0","import { LinearObjectPool } from \"./LinearObjectPool\";\r\nfunction trueMod(a, b) {\r\n    return ((a % b) + b) % b;\r\n}\r\nfunction reduceAngle(angle) {\r\n    return trueMod(angle + Math.PI, Math.PI * 2) - Math.PI;\r\n}\r\nfunction reduceAngleCentered(center, angle) {\r\n    return reduceAngle(angle - center) + center;\r\n}\r\nconst FUDGE_THETA = Math.PI / 100000;\r\nfunction greaterThanEqualsFavorsTrue(a, b) {\r\n    return a + FUDGE_THETA >= b;\r\n}\r\nconst DEBUG = false;\r\nlet tmp = 0;\r\nconst ANGLE_RANGE = Math.PI / 100000;\r\nclass ProjectionPath {\r\n    constructor() {\r\n        this.angles = new Float64Array(32);\r\n        this.anglesLength = 0;\r\n    }\r\n    static id(view, x, y) {\r\n        return `${view.id},${x},${y}`;\r\n    }\r\n    init(view, x, y, isRoot = false, offsetX, offsetY, rootAngleMin = 0, rootAngleMax = Math.PI * 2) {\r\n        this.view = view;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.anglesLength = 0;\r\n        this.centerAngle = Math.atan2(y, x);\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        if (isRoot) {\r\n            //    this.angles.push(\r\n            //        0,\r\n            //        Math.PI / 2\r\n            //    );\r\n            if (rootAngleMin === 0 && rootAngleMax === Math.PI * 2) {\r\n                for (let i = 0; i < 3; i++) {\r\n                    this.angles[this.anglesLength++] = (Math.PI * 2 / 3 * (i + .5));\r\n                    this.angles[this.anglesLength++] = (Math.PI * 2 / 3 * (i + 1.5));\r\n                }\r\n            }\r\n            else {\r\n                let isOpen = false;\r\n                for (let ang = rootAngleMin; ang < rootAngleMax; ang += isOpen ? Math.PI * 2 / 3 : 0) {\r\n                    this.angles[this.anglesLength++] = (ang);\r\n                    isOpen = !isOpen;\r\n                }\r\n                if (isOpen) {\r\n                    this.angles[this.anglesLength++] = rootAngleMax;\r\n                }\r\n                if (tmp++ < 10)\r\n                    console.log(this.angles, rootAngleMin, rootAngleMax);\r\n            }\r\n        }\r\n        else {\r\n            let minTheta = Infinity;\r\n            let maxTheta = -Infinity;\r\n            for (let ox = 0; ox < 2; ox++) {\r\n                for (let oy = 0; oy < 2; oy++) {\r\n                    const theta = reduceAngleCentered(this.centerAngle, Math.atan2(y - offsetY + oy, x - offsetX + ox));\r\n                    if (theta < minTheta)\r\n                        minTheta = theta;\r\n                    if (theta > maxTheta)\r\n                        maxTheta = theta;\r\n                }\r\n            }\r\n            this.minTheta = minTheta;\r\n            this.maxTheta = maxTheta;\r\n            this.angles[this.anglesLength++] = minTheta;\r\n            this.angles[this.anglesLength++] = minTheta;\r\n            this.angles[this.anglesLength++] = maxTheta;\r\n            this.angles[this.anglesLength++] = maxTheta;\r\n        }\r\n        this.id = ProjectionPath.id(view, x, y);\r\n        this.isRoot = isRoot;\r\n        return this;\r\n    }\r\n    addRange(from, to) {\r\n        this.addRangeImpl(reduceAngleCentered(this.centerAngle, from), reduceAngleCentered(this.centerAngle, to));\r\n    }\r\n    addRangeImpl(from, to) {\r\n        if (this.isRoot)\r\n            return;\r\n        if (DEBUG)\r\n            console.log('adding range', this.id, from, to);\r\n        if (to === from) {\r\n            return;\r\n        }\r\n        if (to < from) {\r\n            // console.log(to, from);\r\n            this.addRangeImpl(to, from);\r\n            return;\r\n        }\r\n        let startIndex = 0;\r\n        for (; startIndex < this.angles.length; startIndex++) {\r\n            if (startIndex % 2 === 1 ?\r\n                this.angles[startIndex] + FUDGE_THETA >= from\r\n                : this.angles[startIndex] >= from + FUDGE_THETA) {\r\n                break;\r\n            }\r\n        }\r\n        let endIndex = startIndex;\r\n        for (; endIndex < this.angles.length; endIndex++) {\r\n            if (endIndex % 2 === 1 ?\r\n                this.angles[endIndex] + FUDGE_THETA > to\r\n                : this.angles[endIndex] > FUDGE_THETA + to) {\r\n                break;\r\n            }\r\n        }\r\n        const startIsOutside = startIndex % 2 == 0;\r\n        const endIsOutside = endIndex % 2 == 0;\r\n        const lengthChange = startIndex - endIndex + (startIsOutside ? 1 : 0) + (endIsOutside ? 1 : 0);\r\n        this.angles.copyWithin(endIndex + lengthChange, endIndex, this.anglesLength);\r\n        this.anglesLength += lengthChange;\r\n        if (startIsOutside)\r\n            this.angles[startIndex++] = from;\r\n        if (endIsOutside)\r\n            this.angles[startIndex++] = to;\r\n        // if (startIsOutside && endIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, from, to);\r\n        // } else if (startIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, from);\r\n        // } else if (endIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, to);\r\n        // } else {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex);\r\n        // }\r\n        return;\r\n    }\r\n    clean() {\r\n        this.view = null; //this ref could be very costly\r\n    }\r\n}\r\nconst EDGE_GLITCH_REDUCTION_DIST = 1 / 100000;\r\nexport class Projector {\r\n    constructor() {\r\n        this.lookup = new Map();\r\n        this.projectionPathPool = new LinearObjectPool(() => new ProjectionPath());\r\n    }\r\n    project(root, offsetX, offsetY, renderRadiusX, renderRadiusY, displayOffsetX, displayOffestY, warpDest, warpProgress) {\r\n        this.projectionPathPool.done();\r\n        this.que = [];\r\n        this.lookup.clear();\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        this.renderRadiusX = renderRadiusX;\r\n        this.renderRadiusY = renderRadiusY;\r\n        this.displayOffsetX = displayOffsetX;\r\n        this.displayOffsetY = displayOffestY;\r\n        const addRoot = (root, x, y, rootAngleMin = 0, rootAngleMax = Math.PI * 2) => {\r\n            if (!root)\r\n                return;\r\n            if (x === 0 && y === 0) {\r\n                if (offsetX <= EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(2 /* left */), -1, y, rootAngleMin, rootAngleMax);\r\n                }\r\n                if (offsetX >= 1 - EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(0 /* right */), 1, y, rootAngleMin, rootAngleMax);\r\n                }\r\n                if (offsetY <= EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(3 /* top */), x, -1, rootAngleMin, rootAngleMax);\r\n                }\r\n                if (offsetY >= 1 - EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(1 /* bottom */), x, 1, rootAngleMin, rootAngleMax);\r\n                }\r\n            }\r\n            const rootPath = this.projectionPathPool.pop().init(root, x, y, true, offsetX, offsetY, rootAngleMin, rootAngleMax);\r\n            this.lookup.set(rootPath.id, rootPath);\r\n            this.que.push(rootPath);\r\n        };\r\n        if (warpProgress === 0) {\r\n            addRoot(root, 0, 0);\r\n        }\r\n        else {\r\n            const angAdd = warpProgress * Math.PI;\r\n            addRoot(root, 0, 0, -Math.PI / 2 + angAdd + 0.1, 3 * Math.PI / 2 - angAdd + 0.1);\r\n            addRoot(warpDest, 0, 0, 3 * Math.PI / 2 - angAdd + 0.1, 3 * Math.PI / 2 + angAdd + 0.1);\r\n        }\r\n        while (this.que.length > 0) {\r\n            const item = this.que.shift();\r\n            this.considerItem(item);\r\n            if (this.que.length > 1000) {\r\n                console.warn('oversize que');\r\n                break;\r\n            }\r\n        }\r\n        return this.lookup.values();\r\n    }\r\n    considerItem(item) {\r\n        if (Math.sqrt(item.x ** 2 + item.y ** 2) > 100)\r\n            return;\r\n        if (item.x >= 0 || item.isRoot)\r\n            this.considerSide(item, true, 1, item.view.getNeighbor(0), item.x + 1, item.y);\r\n        if (item.y >= 0 || item.isRoot)\r\n            this.considerSide(item, false, 1, item.view.getNeighbor(1), item.x, item.y + 1);\r\n        if (item.x < 1 || item.isRoot)\r\n            this.considerSide(item, true, 0, item.view.getNeighbor(2), item.x - 1, item.y);\r\n        if (item.y < 1 || item.isRoot)\r\n            this.considerSide(item, false, 0, item.view.getNeighbor(3), item.x, item.y - 1);\r\n    }\r\n    /**\r\n     *\r\n     * @param axis true = line goes up down\r\n     */\r\n    considerSide(item, axis, offsetZ, nextTile, nextX, nextY) {\r\n        if (nextX - this.offsetX + this.displayOffsetX > this.renderRadiusX ||\r\n            nextX - this.offsetX + 1 + this.displayOffsetX < -this.renderRadiusX ||\r\n            nextY - this.offsetY + this.displayOffsetY > this.renderRadiusY ||\r\n            nextY - this.offsetY + 1 + this.displayOffsetY < -this.renderRadiusY)\r\n            return;\r\n        if (!nextTile)\r\n            return;\r\n        if (DEBUG)\r\n            console.log(\"consider side\", axis, offsetZ, nextTile, nextX, nextY, item.id);\r\n        const lineZ = axis ? item.x + offsetZ - this.offsetX : item.y + offsetZ - this.offsetY;\r\n        const topU = axis ? item.y - this.offsetY : item.x - this.offsetX;\r\n        const bottomU = topU + 1;\r\n        function makeAng(u) {\r\n            return axis ? Math.atan2(u, lineZ) : -Math.atan2(u, lineZ) + Math.PI / 2;\r\n        }\r\n        function projectAng(angle) {\r\n            if (Math.abs(reduceAngle(angle + (axis ? Math.PI / 2 : Math.PI))) < ANGLE_RANGE) {\r\n                return makeAng(topU);\r\n            }\r\n            else if (Math.abs(reduceAngle(angle + (axis ? Math.PI / 2 : 0))) < ANGLE_RANGE) {\r\n                return makeAng(bottomU);\r\n            }\r\n            const slopeUZ = axis ? Math.tan(angle) : Math.tan(Math.PI / 2 - angle);\r\n            const colU = slopeUZ * lineZ;\r\n            if (DEBUG)\r\n                console.log(\"proj\", angle, slopeUZ, colU);\r\n            if ((axis ? Math.cos(angle) : Math.sin(angle)) * lineZ < 0) {\r\n                // return projectAng(-angle);\r\n                return (!axis ? Math.cos(angle) : Math.sin(angle)) < 0 ? makeAng(topU) : makeAng(bottomU);\r\n            }\r\n            if (colU < topU) {\r\n                return makeAng(topU);\r\n            }\r\n            else if (colU > bottomU) {\r\n                return makeAng(bottomU);\r\n            }\r\n            else {\r\n                return angle;\r\n            }\r\n        }\r\n        let newItem = null;\r\n        const considerAngleRange = (fromAng, toAng) => {\r\n            const newFromAng = projectAng(fromAng);\r\n            const newToAng = projectAng(toAng);\r\n            if (DEBUG)\r\n                console.log(\"proj section\", item.id, fromAng, toAng, newFromAng, newToAng);\r\n            if (newFromAng === false || newToAng === false) {\r\n                return;\r\n            }\r\n            if (newFromAng !== newToAng && !(item.isRoot && (axis ? Math.cos(fromAng) : Math.sin(fromAng)) * lineZ < 0 && (axis ? Math.cos(toAng) : Math.sin(toAng)) * lineZ < 0)) {\r\n                if (newItem === null) {\r\n                    const key = ProjectionPath.id(nextTile, nextX, nextY);\r\n                    if (this.lookup.has(key)) {\r\n                        newItem = this.lookup.get(key);\r\n                    }\r\n                    else {\r\n                        newItem = this.projectionPathPool.pop();\r\n                        newItem.init(nextTile, nextX, nextY, false, this.offsetX, this.offsetY);\r\n                        this.lookup.set(key, newItem);\r\n                        this.que.push(newItem);\r\n                    }\r\n                }\r\n                newItem.addRange(newFromAng, newToAng);\r\n            }\r\n        };\r\n        const foldAngleRange = (fromAng, toAng) => {\r\n            if (Math.abs(reduceAngle(toAng - fromAng)) > Math.PI / 2) {\r\n                const mid = reduceAngle((fromAng + toAng) / 2);\r\n                considerAngleRange(reduceAngle(fromAng), mid);\r\n                considerAngleRange(mid, reduceAngle(toAng));\r\n                return;\r\n            }\r\n            else {\r\n                considerAngleRange(reduceAngle(fromAng), reduceAngle(toAng));\r\n            }\r\n        };\r\n        for (let i = 0; i < item.anglesLength / 2; i++) {\r\n            const fromAng = item.angles[2 * i];\r\n            const toAng = item.angles[2 * i + 1];\r\n            if (fromAng === toAng)\r\n                continue;\r\n            foldAngleRange(fromAng, toAng);\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Projector.ts\n// module id = 11\n// module chunks = 0","export class LinearObjectPool {\r\n    constructor(makeT, size = 64) {\r\n        this.usedIndex = 0;\r\n        this.makeT = makeT;\r\n        this.items = [...Array(size)].map(() => makeT());\r\n    }\r\n    pop() {\r\n        if (this.usedIndex + 1 >= this.items.length) {\r\n            this.items.push(this.makeT());\r\n            window.usedSize = this.items.length;\r\n        }\r\n        return this.items[this.usedIndex++];\r\n    }\r\n    done() {\r\n        for (let i = this.usedIndex; i >= 0; i--) {\r\n            this.items[i].clean();\r\n        }\r\n        this.usedIndex = 0;\r\n    }\r\n    clean() {\r\n        this.done();\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/LinearObjectPool.ts\n// module id = 12\n// module chunks = 0","import { TileGrid } from \"./TileGrid\";\r\nimport { ColorTile } from \"./ColorTile\";\r\nimport { strictCompose } from \"./compose\";\r\nimport { TickTackToeTile } from \"./tickTackToe/TickTackToeTile\";\r\nimport { autoWall } from \"./autoWall\";\r\nfunction colorTile(xc, yc, color) {\r\n    return (next) => (x, y) => {\r\n        if (x === xc && y === yc) {\r\n            return new ColorTile(color);\r\n        }\r\n        return next(x, y);\r\n    };\r\n}\r\nfunction dynamicColor(w, h, base = 255) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(`rgb(${((x / w) ** .5 * 255) | 0},${base},${((y / h) ** .5 * 255) | 0})`);\r\n    };\r\n}\r\nfunction rain(sf, offset = 0) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(`hsl(${(((x + offset) / sf) * 360) | 0},50%,50%)`);\r\n    };\r\n}\r\nfunction checkers(...colors) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(colors[(x + y) % colors.length]);\r\n    };\r\n}\r\nfunction cardinal(xc, yc) {\r\n    return strictCompose([\r\n        colorTile(xc + 1, yc, 'red'),\r\n        colorTile(xc, yc + 1, 'green'),\r\n        colorTile(xc - 1, yc, 'blue'),\r\n        colorTile(xc, yc - 1, 'cyan')\r\n    ]);\r\n}\r\nfunction tickTackToeLayer(n = 3) {\r\n    return (next) => (x, y) => {\r\n        return new TickTackToeTile(n);\r\n    };\r\n}\r\nfunction fullColor(color) {\r\n    return solidColorTiles(color);\r\n}\r\nfunction solidColorTiles(color) {\r\n    return (next) => (x, y) => new ColorTile(color);\r\n}\r\nexport function flatSpace() {\r\n    const grid = new TileGrid(9, 9);\r\n    grid.get(2, 1).isolate();\r\n    return grid.get(1, 1);\r\n}\r\nexport function portSpace() {\r\n    const grid1 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"red\")\r\n    ]);\r\n    const grid2 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"blue\")\r\n    ]);\r\n    grid1.get(4, 4).link(0 /* right */, grid2.get(4, 4));\r\n    grid2.get(8, 8).link(1 /* bottom */, grid1.get(0, 0));\r\n    grid2.get(6, 4).link(0 /* right */, grid1.get(2, 4));\r\n    return grid1.get(4, 7);\r\n}\r\nexport function shortWay() {\r\n    const grid = new TileGrid(11, 5, [\r\n        cardinal(5, 2),\r\n        dynamicColor(10, 5)\r\n    ]);\r\n    for (let i = 2; i < 9; i++) {\r\n        grid.get(i, 2).isolate();\r\n    }\r\n    for (let i = 0; i < 2; i++) {\r\n        grid.get(1, i).link(0 /* right */, grid.get(8, i));\r\n    }\r\n    return grid.get(0, 4);\r\n}\r\nexport function threeTurns() {\r\n    const grid = new TileGrid(7, 7, [\r\n        cardinal(2, 2),\r\n        colorTile(0, 0, 'pink'),\r\n        dynamicColor(7, 7)\r\n    ]);\r\n    for (let i = 0; i < 7; i++) {\r\n        if (i === 1 || i === 5) {\r\n            continue;\r\n        }\r\n        grid.get(i, 3).isolate();\r\n        grid.get(3, i).isolate();\r\n    }\r\n    grid.get(3, 5).link(0 /* right */, grid.get(5, 2), 1 /* bottom */);\r\n    return grid.get(2, 2);\r\n}\r\nexport function bridge() {\r\n    const grid = new TileGrid(5, 5, [\r\n        cardinal(2, 2),\r\n        dynamicColor(5, 5)\r\n    ]);\r\n    const bridge = new ColorTile('orange');\r\n    console.log(grid);\r\n    grid.get(0, 0).link(3 /* top */, bridge);\r\n    grid.get(4, 0).link(3 /* top */, bridge, 3 /* top */, { reflect: true });\r\n    grid.get(4, 4).link(0 /* right */, bridge);\r\n    return grid.get(2, 2);\r\n}\r\nexport function fastLane() {\r\n    const S = 27;\r\n    const grid = new TileGrid(S, 4, [\r\n        dynamicColor(S, 4)\r\n    ]);\r\n    for (let i = 0; i < S; i += 2) {\r\n        for (let j = 0; j < 2; j++) {\r\n            if (i < S - 2)\r\n                grid.get(i, j).link(0 /* right */, grid.get(i + 2, j));\r\n            if (i < S - 1)\r\n                grid.get(i + 1, j).isolate();\r\n        }\r\n    }\r\n    return grid.get(0, 3);\r\n}\r\nexport function fastLane2() {\r\n    const shortLength = 10;\r\n    const zoomLevel = 5;\r\n    const longGrid = new TileGrid(shortLength * zoomLevel, 2, [\r\n        rain(shortLength * zoomLevel / 3)\r\n    ]);\r\n    for (let o = 0; o < zoomLevel; o++) {\r\n        const shortGrid = new TileGrid(shortLength, 2, [\r\n            rain(shortLength / 3, o / zoomLevel)\r\n        ]);\r\n        for (let i = 0; i < shortLength; i++) {\r\n            const targ = longGrid.get(i * zoomLevel + o, 0);\r\n            shortGrid.get(i, 1).link(1 /* bottom */, targ);\r\n        }\r\n    }\r\n    return longGrid.get(0, 1);\r\n}\r\nexport function ballPort() {\r\n    const grid1 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"red\")\r\n    ]);\r\n    const grid2 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"blue\")\r\n    ]);\r\n    const center1 = grid1.get(4, 4);\r\n    const center2 = grid2.get(4, 4);\r\n    let bridge;\r\n    for (let i = 0; i < 4; i++) {\r\n        const reverse = (i + 2) % 4;\r\n        if (i % 2 === 0)\r\n            bridge = new ColorTile(\"pink\");\r\n        center1.getReference(i).to.link(reverse, bridge);\r\n        center2.getReference(reverse).to.link(i, bridge);\r\n    }\r\n    return grid1.get(4, 7);\r\n}\r\nexport function branches(n = 7) {\r\n    if (n === 0) {\r\n        return new ColorTile(\"red\");\r\n    }\r\n    const color = `hsl(${Math.random() * 360},50%,50%)`;\r\n    const out = new ColorTile(color);\r\n    function addSide(side) {\r\n        const bridge = new ColorTile(color);\r\n        out.link(side, bridge, 1 /* bottom */);\r\n        bridge.link(3 /* top */, branches(n - 1), 1 /* bottom */);\r\n    }\r\n    addSide(3 /* top */);\r\n    addSide(1 /* bottom */);\r\n    addSide(2 /* left */);\r\n    addSide(0 /* right */);\r\n    return out;\r\n}\r\nexport function branches2() {\r\n    const S = 4;\r\n    function inner(n = 7) {\r\n        const color = `hsl(${Math.random() * 360},50%,50%)`;\r\n        if (n === 0) {\r\n            return new TileGrid(S, S, [\r\n                solidColorTiles(color)\r\n            ]);\r\n        }\r\n        const out = new TileGrid(S, S, [\r\n            solidColorTiles(color)\r\n        ]);\r\n        const north = inner(n - 1);\r\n        const east = inner(n - 1);\r\n        const west = inner(n - 1);\r\n        for (let i = 0; i < S; i++) {\r\n            out.get(i, 0).link(3 /* top */, north.get(i, S - 1));\r\n            out.get(0, S - 1 - i).link(2 /* left */, east.get(i, S - 1), 1 /* bottom */);\r\n            out.get(S - 1, i).link(0 /* right */, west.get(i, S - 1), 1 /* bottom */);\r\n        }\r\n        return out;\r\n    }\r\n    return inner().get(Math.floor(S / 2), S - 1);\r\n}\r\nexport function mirror() {\r\n    const grid = new TileGrid(5, 5, [\r\n        dynamicColor(5, 5)\r\n    ]);\r\n    for (let i = 1; i < 4; i++) {\r\n        grid.get(2, i).link(0 /* right */, grid.get(2, i), 0 /* right */, {\r\n            reflect: true\r\n        });\r\n    }\r\n    return grid.get(0, 4);\r\n}\r\nexport function tickTackToeBasic() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer()\r\n    ]);\r\n    return grid.get(0, 2);\r\n}\r\nexport function tickTackToeDonut() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer()\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i));\r\n        grid.get(i, 0).link(3 /* top */, grid.get(i, 2));\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeDonutOffset() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(4)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i));\r\n        grid.get((i + 1) % 3, 0).link(3 /* top */, grid.get(i, 2));\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeKlign() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(4)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i), 0 /* right */, { reflect: false });\r\n        grid.get(i, 0).link(3 /* top */, grid.get(2 - i, 2), 1 /* bottom */, { reflect: true });\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeMirror() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(5)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(0, i), 2 /* left */, { reflect: true, addReverse: false });\r\n        grid.get(2, i).link(0 /* right */, grid.get(2, i), 0 /* right */, { reflect: true, addReverse: false });\r\n        grid.get(i, 2).link(1 /* bottom */, grid.get(i, 2), 1 /* bottom */, { reflect: true, addReverse: false });\r\n        grid.get(i, 0).link(3 /* top */, grid.get(i, 0), 3 /* top */, { reflect: true, addReverse: false });\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function mobius(W = 5, H = 5) {\r\n    const grid = new TileGrid(W, H, [\r\n        dynamicColor(W, H)\r\n    ]);\r\n    for (let i = 0; i < H; i++) {\r\n        grid.get(W - 1, i).link(0 /* right */, grid.get(0, H - i - 1), 2 /* left */, {\r\n            reflect: true\r\n        });\r\n    }\r\n    return grid.get(0, H - 1);\r\n}\r\nexport function spiral(S = 10) {\r\n    let len = S - 2;\r\n    let dir = 0 /* right */;\r\n    const grid = new TileGrid(S, S, [\r\n        dynamicColor(S, S)\r\n    ]);\r\n    let tile = grid.get(0, S - 1);\r\n    while (len > 2) {\r\n        len -= 1 / 2;\r\n        for (let i = 0; i < len; i++) {\r\n            tile = tile.links[dir].to;\r\n        }\r\n        const ot = tile;\r\n        const nextDir = (dir - 1) & 0b11;\r\n        const mid = tile.links[dir].to;\r\n        tile = mid.links[nextDir].to;\r\n        mid.isolate();\r\n        ot.link(dir, tile, (nextDir + 2) & 3);\r\n        dir = nextDir;\r\n    }\r\n    return grid.get(0, S - 1);\r\n}\r\nexport function wheel(S = 5) {\r\n    const center = new TileGrid(S, S, [\r\n        dynamicColor(S, S)\r\n    ]);\r\n    const root = center.get(0, 0);\r\n    const edgeLength = S + 1;\r\n    const edge = new TileGrid(edgeLength * 4, 1, [\r\n        rain(edgeLength * 4, 0)\r\n    ]);\r\n    edge.get(0, 0).link(2 /* left */, edge.get(edgeLength * 4 - 1, 0));\r\n    let dest = root.getView(1 /* bottom */);\r\n    for (let i = 0; i < edgeLength * 4; i++) {\r\n        if (i % edgeLength === 1)\r\n            continue;\r\n        edge.get(i, 0).getView(0).link(1 /* bottom */, dest, 3 /* top */);\r\n        if (i % edgeLength === 0) {\r\n            dest = dest.rotate(3 /* top */);\r\n        }\r\n        else {\r\n            dest = dest.getNeighbor(0 /* right */);\r\n        }\r\n    }\r\n    return center.get(S / 2 | 0, S / 2 | 0);\r\n}\r\nexport function makeHubRoom(worlds, color = 'gold') {\r\n    const root = [new ColorTile('red'), new ColorTile('pink')];\r\n    for (let i = 0; i < worlds.length - 1; i++) {\r\n        const left = worlds[i];\r\n        const right = worlds[(i + 1)];\r\n        if (left instanceof Array && right instanceof Array) {\r\n            left[1].forEach((e, i) => {\r\n                e.link(0 /* right */, right[0][i]);\r\n            });\r\n        }\r\n    }\r\n    const out = worlds.reduceRight(([rightTile, rightBridge], worldRoot) => {\r\n        const hubTile = new ColorTile(color);\r\n        const hubBridge = new ColorTile(color);\r\n        const leftBridge = new ColorTile(color);\r\n        const leftTile = new ColorTile(color);\r\n        hubTile.link(0 /* right */, rightTile);\r\n        hubBridge.link(0 /* right */, rightBridge);\r\n        leftTile.link(0 /* right */, hubTile);\r\n        leftBridge.link(0 /* right */, hubBridge);\r\n        hubBridge.link(1 /* bottom */, hubTile);\r\n        if (worldRoot !== false)\r\n            hubBridge.link(3 /* top */, worldRoot instanceof Array ? worldRoot[1][0] : worldRoot);\r\n        if (worldRoot instanceof Array)\r\n            leftBridge.link(3 /* top */, worldRoot[0][0]);\r\n        hubTile.link(3 /* top */, hubBridge);\r\n        leftBridge.link(1 /* bottom */, leftTile);\r\n        return (worldRoot instanceof Array) ? [leftTile, leftBridge] : [hubTile, hubBridge];\r\n    }, root);\r\n    console.log(root);\r\n    const base = root.map(e => e.links[2 /* left */].to);\r\n    root.map(e => e.isolate());\r\n    return [out, base];\r\n}\r\nexport function hubRoom() {\r\n    const data = makeHubRoom([\r\n        makeHubRoom([\r\n            portSpace(),\r\n            ballPort(),\r\n            mirror(),\r\n            bridge()\r\n        ], 'pink'),\r\n        makeHubRoom([\r\n            shortWay(),\r\n            fastLane(),\r\n            fastLane2(),\r\n            threeTurns()\r\n        ], 'cyan'),\r\n        makeHubRoom([\r\n            branches(),\r\n            branches2(),\r\n        ], 'red'),\r\n        makeHubRoom([\r\n            tickTackToeBasic(),\r\n            tickTackToeDonut(),\r\n            tickTackToeKlign(),\r\n            tickTackToeMirror(),\r\n            tickTackToeDonutOffset()\r\n        ], 'grey'),\r\n        makeHubRoom([\r\n            mobius(),\r\n            mobius(30),\r\n            spiral(),\r\n            wheel()\r\n        ], 'blue')\r\n    ]);\r\n    autoWall(data[0][1]);\r\n    return data[0][1];\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/testLevels.ts\n// module id = 13\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nexport class TileGrid {\r\n    constructor(width, height, layers = []) {\r\n        const getTiles = layers.reduce((a, b) => (next) => a(b(next)), (x) => x)((x, y) => new Tile());\r\n        this.tiles = [...Array(height)].map((_, y) => [...Array(width)].map((_, x) => getTiles(x, y)));\r\n        this.tiles.forEach((row, y) => {\r\n            row.forEach((tile, x) => {\r\n                if (!tile)\r\n                    return;\r\n                if (y !== 0 && this.tiles[y - 1][x]) {\r\n                    this.tiles[y - 1][x].link(1 /* bottom */, tile);\r\n                }\r\n                if (x !== 0 && row[x - 1]) {\r\n                    row[x - 1].link(0 /* right */, tile);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    get(x, y) {\r\n        return this.tiles[y][x];\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TileGrid.ts\n// module id = 14\n// module chunks = 0","import { makeDirMtx, dirMtxProduct } from \"./DirMtx\";\r\nimport { reverseSide } from \"./Side\";\r\nexport class SideReference {\r\n    constructor(to, mtx, destSide) {\r\n        this.to = to;\r\n        this.mtx = mtx;\r\n        this.destSide = destSide;\r\n    }\r\n    static fromOpts(toTile, fromSide, destSide, reflect) {\r\n        return new SideReference(toTile, dirMtxProduct(makeDirMtx(-reverseSide(destSide), reflect), fromSide), destSide);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SideReference.ts\n// module id = 15\n// module chunks = 0","import { dirMtxApply, dirMtxInverse, dirMtxProductImpl } from \"./DirMtx\";\r\nimport { reverseSide } from \"./Side\";\r\nconst lookupMaps = [...Array(8)].map((i) => {\r\n    return new WeakMap();\r\n});\r\nexport class TileView {\r\n    static lookup(tile, orientation) {\r\n        return tile.tileViews[orientation];\r\n        // const map = lookupMaps[orientation];\r\n        // if(!map.has(tile)){\r\n        //     const view = new TileView(tile, orientation);\r\n        //     map.set(tile, view);\r\n        //     return view;\r\n        // }\r\n        // return map.get(tile);\r\n    }\r\n    constructor(tile, orientation) {\r\n        this.tile = tile;\r\n        this.orientation = orientation;\r\n        this.id = `${tile.id},${orientation}`;\r\n    }\r\n    computeSide(i) {\r\n        return dirMtxApply(dirMtxInverse(this.orientation), i);\r\n    }\r\n    getNeighbor(i) {\r\n        const edge = this.tile.getReference(this.computeSide(i));\r\n        if (edge) {\r\n            return TileView.lookup(edge.to, dirMtxProductImpl(this.orientation, edge.mtx));\r\n        }\r\n        return null;\r\n    }\r\n    stepOn(t) {\r\n        this.tile.stepOn(t);\r\n    }\r\n    interact(t) {\r\n        this.tile.interact(t);\r\n    }\r\n    track(entity) {\r\n        this.tile.track(entity);\r\n    }\r\n    link(fromSide, toTile, toSide = reverseSide(fromSide), { reflect = false, addReverse = true } = {}) {\r\n        this.tile.link(this.computeSide(fromSide), toTile.tile, toTile.computeSide(toSide), {\r\n            reflect: !reflect !== !((toTile.orientation ^ this.orientation) & 0b100),\r\n            addReverse\r\n        });\r\n    }\r\n    rotate(mtx) {\r\n        return this.tile.getView(dirMtxProductImpl(mtx, this.orientation));\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TileView.ts\n// module id = 16\n// module chunks = 0","import { ColorTile } from \"../ColorTile\";\r\nimport { TILE_SIZE } from \"../opts\";\r\nimport { strictCompose } from \"../compose\";\r\nvar Turn;\r\n(function (Turn) {\r\n    Turn[Turn[\"RED\"] = -1] = \"RED\";\r\n    Turn[Turn[\"NONE\"] = 0] = \"NONE\";\r\n    Turn[Turn[\"BLACK\"] = 1] = \"BLACK\";\r\n})(Turn || (Turn = {}));\r\nfunction turnColor(turn) {\r\n    return turn === Turn.RED ? \"RED\" : turn === Turn.BLACK ? \"black\" : \"grey\";\r\n}\r\nclass TickTackToeGame {\r\n    constructor() {\r\n        this.turn = Turn.RED;\r\n        this.won = Turn.NONE;\r\n        this.blankTiles = 0;\r\n    }\r\n}\r\nconst MARGIN = TILE_SIZE / 6;\r\nfunction singleStepMovement(dir) {\r\n    return (t) => {\r\n        if (!t)\r\n            return null;\r\n        return t.getNeighbor(dir);\r\n    };\r\n}\r\nfunction movement(dirs) {\r\n    return strictCompose(dirs.map(singleStepMovement));\r\n}\r\nconst movementMethods = [\r\n    [3 /* top */, 1 /* bottom */].map(singleStepMovement),\r\n    [2 /* left */, 0 /* right */].map(singleStepMovement),\r\n    [\r\n        [2 /* left */, 1 /* bottom */],\r\n        [3 /* top */, 0 /* right */]\r\n    ].map(movement),\r\n    [\r\n        [1 /* bottom */, 2 /* left */],\r\n        [0 /* right */, 3 /* top */]\r\n    ].map(movement),\r\n    [\r\n        [2 /* left */, 3 /* top */],\r\n        [1 /* bottom */, 0 /* right */]\r\n    ].map(movement),\r\n    [\r\n        [3 /* top */, 2 /* left */],\r\n        [0 /* right */, 1 /* bottom */]\r\n    ].map(movement)\r\n];\r\nexport class TickTackToeTile extends ColorTile {\r\n    constructor(lengthForWin = 3) {\r\n        super(\"white\");\r\n        this.occupied = Turn.NONE;\r\n        this.game = null;\r\n        this.isWinningLine = false;\r\n        this.lengthForWin = lengthForWin;\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        super.render(ctx, t, playerDist, playerShear);\r\n        ctx.fillStyle = turnColor(this.occupied);\r\n        const margin = this.game && ((this.game.won !== Turn.NONE || this.game.blankTiles === 0) && !this.isWinningLine) ? MARGIN * 2 : MARGIN;\r\n        ctx.fillRect(margin, margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);\r\n        if (this.game && t - this.stepTime < 100) {\r\n            ctx.strokeStyle = turnColor(this.game.turn);\r\n            ctx.lineWidth = 5;\r\n            ctx.strokeRect(margin, margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);\r\n        }\r\n    }\r\n    tallyInDir(movmentPattern) {\r\n        let view = this.getView(0);\r\n        for (let i = 0; i < this.lengthForWin; i++) {\r\n            view = movmentPattern(view);\r\n            if (!view || !(view.tile instanceof TickTackToeTile && view.tile.occupied === this.occupied)) {\r\n                return i;\r\n            }\r\n        }\r\n        return this.lengthForWin;\r\n    }\r\n    drawWinningLine(movmentPattern) {\r\n        let view = this.getView(0);\r\n        for (let i = 0; i < this.lengthForWin; i++) {\r\n            view = movmentPattern(view);\r\n            if (!view || !(view.tile instanceof TickTackToeTile && view.tile.occupied === this.occupied)) {\r\n                return;\r\n            }\r\n            view.tile.isWinningLine = true;\r\n        }\r\n    }\r\n    didWin() {\r\n        for (let pair of movementMethods) {\r\n            const n = this.tallyInDir(pair[0]) + this.tallyInDir(pair[1]) + 1;\r\n            if (n >= this.lengthForWin) {\r\n                this.drawWinningLine(pair[0]);\r\n                this.drawWinningLine(pair[1]);\r\n                this.isWinningLine = true;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    linkGame(game = new TickTackToeGame()) {\r\n        if (this.game !== game) {\r\n            this.occupied = Turn.NONE;\r\n            this.isWinningLine = false;\r\n            this.game = game;\r\n            game.blankTiles++;\r\n            this.links.forEach((link) => {\r\n                if (!link)\r\n                    return;\r\n                const tile = link.to;\r\n                if (tile instanceof TickTackToeTile) {\r\n                    tile.linkGame(game);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    stepOn(t) {\r\n        super.stepOn(t);\r\n        if (this.game === null) {\r\n            this.linkGame();\r\n        }\r\n    }\r\n    interact() {\r\n        if (this.game === null || this.game.won !== Turn.NONE || this.game.blankTiles === 0) {\r\n            this.linkGame();\r\n            return;\r\n        }\r\n        if (this.occupied === Turn.NONE) {\r\n            this.occupied = this.game.turn;\r\n            this.game.turn = -this.game.turn;\r\n            this.game.blankTiles--;\r\n            if (this.didWin()) {\r\n                this.game.won = this.occupied;\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tickTackToe/TickTackToeTile.ts\n// module id = 17\n// module chunks = 0","import { WallTile } from \"./WallTile\";\r\nexport function autoWall(root) {\r\n    console.time(\"wall\");\r\n    const explored = new Set();\r\n    const wallsToLink = new Set();\r\n    let maxExplore = 1000;\r\n    explored.add(root);\r\n    console.time(\"wallExplore\");\r\n    for (let tile of explored) {\r\n        for (let i = 0; i < 4; i++) {\r\n            const edge = tile.getReference(i);\r\n            if (edge) {\r\n                const nextTile = edge.to;\r\n                if (nextTile instanceof WallTile || explored.has(nextTile)) {\r\n                    continue;\r\n                }\r\n                explored.add(nextTile);\r\n            }\r\n            else {\r\n                const nt = new WallTile();\r\n                wallsToLink.add(nt);\r\n                nt.link(2 /* left */, tile, i);\r\n            }\r\n        }\r\n    }\r\n    console.timeEnd(\"wallExplore\");\r\n    console.time(\"wallLink\");\r\n    for (let wall of wallsToLink) {\r\n        const base = wall.getView(0).getNeighbor(2 /* left */);\r\n        if (!base)\r\n            continue;\r\n        for (let dir of [3 /* top */, 1 /* bottom */]) {\r\n            if (wall.getReference(dir))\r\n                continue;\r\n            const nextBase = base.getNeighbor(dir);\r\n            if (nextBase.tile instanceof WallTile)\r\n                continue;\r\n            const targWall = nextBase.getNeighbor(0 /* right */);\r\n            if (!(targWall.tile instanceof WallTile))\r\n                continue;\r\n            wall.getView(0).link(dir, targWall);\r\n        }\r\n    }\r\n    console.timeEnd(\"wallLink\");\r\n    for (let wall of wallsToLink) {\r\n        const wallShade = wall.wallShade;\r\n        for (let dir of [3 /* top */, 1 /* bottom */]) {\r\n            let view = wall.getView(0).getNeighbor(dir);\r\n            while (view && view.tile instanceof WallTile && view.tile !== wall) {\r\n                wallsToLink.delete(view.tile);\r\n                view.tile.wallShade = wallShade;\r\n                view = view.getNeighbor(dir);\r\n            }\r\n        }\r\n    }\r\n    console.timeEnd(\"wall\");\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/autoWall.ts\n// module id = 18\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst PERSPECTIVE = 1 / 5;\r\nexport class WallTile extends Tile {\r\n    constructor(height = 1) {\r\n        super();\r\n        this.walkable = false;\r\n        this.height = height;\r\n        this.wallShade = 1 - 0.5 * Math.random();\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        super.render(ctx, t, playerDist, playerShear);\r\n        if (playerDist > 0) {\r\n            ctx.globalAlpha = this.wallShade;\r\n            ctx.fillStyle = \"grey\";\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, 0);\r\n            ctx.lineTo(playerDist * PERSPECTIVE * this.height, playerShear * PERSPECTIVE * this.height);\r\n            ctx.lineTo(playerDist * PERSPECTIVE * this.height, (playerShear + TILE_SIZE) * PERSPECTIVE * this.height + TILE_SIZE);\r\n            ctx.lineTo(0, TILE_SIZE);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/WallTile.ts\n// module id = 19\n// module chunks = 0","import { RenderableEntity } from \"./RenderableEntity\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nimport { Bolt } from \"./Bolt\";\r\nconst PLAYER_SIZE = 1 / 3;\r\nconst onScreenSize = TILE_SIZE * PLAYER_SIZE;\r\nexport class Player extends RenderableEntity {\r\n    constructor(spawnPt, app) {\r\n        super(PLAYER_SIZE, PLAYER_SIZE, spawnPt);\r\n        this.app = app;\r\n    }\r\n    render(ctx) {\r\n        ctx.fillStyle = \"black\";\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(0, 0, onScreenSize / 2, onScreenSize / 2);\r\n        ctx.fillRect(0, 0, onScreenSize / 2, onScreenSize / 2);\r\n        ctx.strokeRect(0, onScreenSize / 2, onScreenSize, onScreenSize / 2);\r\n        ctx.fillRect(0, onScreenSize / 2, onScreenSize, onScreenSize / 2);\r\n    }\r\n    shoot(dir = this.lastMovementDir) {\r\n        const bolt = new Bolt(dir, this.center.view);\r\n        bolt.move(this.center.pt.x - bolt.center.pt.x, this.center.pt.y - bolt.center.pt.y);\r\n        this.app.addStepable(bolt);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Player.ts\n// module id = 20\n// module chunks = 0","import { ViewCursor } from \"./ViewCursor\";\r\nexport class Entity {\r\n    constructor(width, height, baseTile) {\r\n        this.trackWidth = 2;\r\n        this.trackHeight = 2;\r\n        this.init(width, height, baseTile);\r\n    }\r\n    respawn(view) {\r\n        this.init(this.width, this.height, view);\r\n    }\r\n    init(width, height, baseTile) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if (width > 1 || height > 1)\r\n            throw new RangeError(\"we do not yet suport entities larger than one tile\");\r\n        this.trackingTiles = Array(this.trackWidth);\r\n        this.trackingTilesOld = Array(this.trackWidth);\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            this.trackingTiles[x] = Array(this.trackHeight);\r\n            this.trackingTilesOld[x] = Array(this.trackHeight);\r\n            for (let y = 0; y < this.trackHeight; y++) {\r\n                const trackingPointX = width / (this.trackWidth - 1) * x, trackingPointY = height / (this.trackHeight - 1) * y;\r\n                const tracker = new ViewCursor(baseTile, 0.5 - (width / 2) + trackingPointX, 0.5 - (height / 2) + trackingPointY, trackingPointX, trackingPointY);\r\n                this.trackingTiles[x][y] = tracker;\r\n                this.trackingTilesOld[x][y] = tracker.clone();\r\n            }\r\n        }\r\n        this.center = new ViewCursor(baseTile, 0.5, 0.5, width / 2, height / 2);\r\n        this.centerOld = this.center.clone();\r\n    }\r\n    move(dx, dy) {\r\n        let xSide = dx < 0 ? 2 /* left */ : 0 /* right */;\r\n        let ySide = dy < 0 ? 3 /* top */ : 1 /* bottom */;\r\n        let xLeft = Math.abs(dx);\r\n        let yLeft = Math.abs(dy);\r\n        let xLocked = xLeft === 0;\r\n        let yLocked = yLeft === 0;\r\n        let i = 0;\r\n        this.lastMovementDir = xLeft >= yLeft ? xSide : ySide;\r\n        while ((xLeft > 0 || yLeft > 0) && i < 100) {\r\n            i++;\r\n            if (!xLocked && xLeft > 0) {\r\n                let oPosn = xLeft;\r\n                xLeft = this.tryMove(xSide, xLeft);\r\n                yLocked = yLocked && (oPosn === xLeft || yLeft <= 0);\r\n                xLocked = true;\r\n            }\r\n            if (yLocked)\r\n                break;\r\n            if (!yLocked && yLeft > 0) {\r\n                let oPosn = yLeft;\r\n                yLeft = this.tryMove(ySide, yLeft);\r\n                xLocked = xLocked && (oPosn === yLeft || xLeft <= 0);\r\n                yLocked = true;\r\n            }\r\n            if (xLocked)\r\n                break;\r\n        }\r\n        return xLeft === 0 && yLeft === 0;\r\n    }\r\n    tryMove(side, dist) {\r\n        let distLeft = dist;\r\n        let i = 0;\r\n        while (distLeft > 0 && i < 100) {\r\n            i++;\r\n            //move to edge of tile\r\n            let maxMovement = distLeft;\r\n            for (let x = 0; x < this.trackWidth; x++) {\r\n                for (let y = 0; y < this.trackWidth; y++) {\r\n                    const newDist = this.trackingTiles[x][y].movementUpToEdge(side);\r\n                    if (newDist < maxMovement)\r\n                        maxMovement = newDist;\r\n                }\r\n            }\r\n            const newDist = this.center.movementUpToEdge(side);\r\n            if (newDist < maxMovement)\r\n                maxMovement = newDist;\r\n            if (maxMovement > 0) {\r\n                for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        this.trackingTiles[x][y].moveWithinTile(side, maxMovement);\r\n                    }\r\n                }\r\n                this.center.moveWithinTile(side, maxMovement);\r\n            }\r\n            if (maxMovement === distLeft) {\r\n                distLeft = 0;\r\n                break;\r\n            }\r\n            distLeft -= maxMovement;\r\n            //cross edge\r\n            let crossingValid = true;\r\n            for (let x = 0; x < this.trackWidth; x++) {\r\n                for (let y = 0; y < this.trackWidth; y++) {\r\n                    const thisTracker = this.trackingTiles[x][y];\r\n                    this.trackingTilesOld[x][y].copy(thisTracker);\r\n                    crossingValid = crossingValid && thisTracker.tryCrossEdge(side) && thisTracker.view.tile.walkable;\r\n                }\r\n            }\r\n            this.centerOld.copy(this.center);\r\n            crossingValid = crossingValid && this.center.tryCrossEdge(side) && this.center.view.tile.walkable;\r\n            if (crossingValid) {\r\n                outer: for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        const tgtView = this.trackingTiles[x][y].view;\r\n                        if (x !== 0) {\r\n                            const leftView = this.trackingTiles[x - 1][y].view;\r\n                            crossingValid = crossingValid && (tgtView === leftView || tgtView.getNeighbor(2 /* left */) === leftView);\r\n                        }\r\n                        if (y !== 0) {\r\n                            const topView = this.trackingTiles[x][y - 1].view;\r\n                            crossingValid = crossingValid && (tgtView === topView || tgtView.getNeighbor(3 /* top */) === topView);\r\n                        }\r\n                        if (!crossingValid) {\r\n                            break outer;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!crossingValid) {\r\n                for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        this.trackingTiles[x][y].copy(this.trackingTilesOld[x][y]);\r\n                    }\r\n                }\r\n                this.center.copy(this.centerOld);\r\n                break;\r\n            }\r\n        }\r\n        return distLeft;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Entity.ts\n// module id = 21\n// module chunks = 0","import { Cursor } from \"./Cursor\";\r\nexport class ViewCursor {\r\n    constructor(view, x, y, onEntityX, onEntityY) {\r\n        this.view = view;\r\n        this.pt = new Cursor({ x, y });\r\n        this.onEntityX = onEntityX;\r\n        this.onEntityY = onEntityY;\r\n    }\r\n    movementUpToEdge(dir) {\r\n        switch (dir) {\r\n            case 2 /* left */: return this.pt.x;\r\n            case 0 /* right */: return 1 - this.pt.x;\r\n            case 3 /* top */: return this.pt.y;\r\n            case 1 /* bottom */: return 1 - this.pt.y;\r\n        }\r\n    }\r\n    moveWithinTile(dir, dist) {\r\n        this.pt.step(dir, dist);\r\n    }\r\n    tryCrossEdge(dir) {\r\n        if (this.movementUpToEdge(dir) === 0) {\r\n            const next = this.view.getNeighbor(dir);\r\n            if (!next)\r\n                return false;\r\n            this.pt.step(dir, -1);\r\n            this.view = next;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    copy(other) {\r\n        this.pt = other.pt.fork();\r\n        this.view = other.view;\r\n        this.onEntityY = other.onEntityY;\r\n        this.onEntityX = other.onEntityX;\r\n    }\r\n    clone() {\r\n        return new ViewCursor(this.view, this.pt.x, this.pt.y, this.onEntityX, this.onEntityY);\r\n    }\r\n    move(dx, dy) {\r\n        let xSide = dx < 0 ? 2 /* left */ : 0 /* right */;\r\n        let ySide = dy < 0 ? 3 /* top */ : 1 /* bottom */;\r\n        let xLeft = Math.abs(dx);\r\n        let yLeft = Math.abs(dy);\r\n        let xLocked = xLeft === 0;\r\n        let yLocked = yLeft === 0;\r\n        let i = 0;\r\n        while ((xLeft > 0 || yLeft > 0) && i < 100) {\r\n            i++;\r\n            if (!xLocked && xLeft > 0) {\r\n                let oPosn = xLeft;\r\n                xLeft = this.tryMove(xSide, xLeft);\r\n                yLocked = yLocked && (oPosn === xLeft || yLeft <= 0);\r\n                xLocked = true;\r\n            }\r\n            if (yLocked)\r\n                break;\r\n            if (!yLocked && yLeft > 0) {\r\n                let oPosn = yLeft;\r\n                yLeft = this.tryMove(ySide, yLeft);\r\n                xLocked = xLocked && (oPosn === yLeft || xLeft <= 0);\r\n                yLocked = true;\r\n            }\r\n            if (xLocked)\r\n                break;\r\n        }\r\n        if (xLeft !== 0 && yLeft !== 0)\r\n            console.log(xLeft, yLeft);\r\n        return xLeft === 0 && yLeft === 0;\r\n    }\r\n    tryMove(dir, dist) {\r\n        let i = 0;\r\n        let left = dist;\r\n        while (left > 0 && i < 100) {\r\n            i--;\r\n            const canMove = Math.min(this.movementUpToEdge(dir), left);\r\n            if (canMove > 0) {\r\n                this.moveWithinTile(dir, canMove);\r\n            }\r\n            left -= canMove;\r\n            if (left === canMove)\r\n                break;\r\n            if (!this.tryCrossEdge(dir))\r\n                break;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ViewCursor.ts\n// module id = 22\n// module chunks = 0","import { RenderableEntity } from \"./RenderableEntity\";\r\nimport { getDelta } from \"./Side\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst BOLT_SPEED = 10 / 1000;\r\nexport class Bolt extends RenderableEntity {\r\n    constructor(dir, tile) {\r\n        super(dir & 1 ? 1 / 6 : 5 / 6, dir & 1 ? 5 / 6 : 1 / 6, tile);\r\n        this.age = 0;\r\n        this.dir = dir;\r\n        this.dirPt = getDelta(dir);\r\n    }\r\n    step(dt) {\r\n        this.age += dt;\r\n        const hitWall = !this.move(this.dirPt.x * BOLT_SPEED * dt, this.dirPt.y * BOLT_SPEED * dt);\r\n        if (hitWall) {\r\n            this.age += dt * 10;\r\n        }\r\n        const stayAlive = this.age < 10000;\r\n        if (!stayAlive)\r\n            this.kill();\r\n        return stayAlive;\r\n    }\r\n    render(ctx) {\r\n        ctx.lineWidth = 2;\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(0, 0, this.width * TILE_SIZE, this.height * TILE_SIZE);\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.strokeRect(0, 0, this.width * TILE_SIZE, this.height * TILE_SIZE);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Bolt.ts\n// module id = 23\n// module chunks = 0"],"sourceRoot":""}