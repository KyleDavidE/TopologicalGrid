{"version":3,"sources":["webpack:///webpack/bootstrap 5d0cfe61d4c0506ec9ce","webpack:///./src/opts.ts","webpack:///./src/Side.ts","webpack:///./src/DirMtx.ts","webpack:///./src/Cursor.ts","webpack:///./src/Tile.ts","webpack:///./src/ColorTile.ts","webpack:///./src/compose.ts","webpack:///./src/RenderableEntity.ts","webpack:///./src/index.ts","webpack:///./src/App.ts","webpack:///./src/Renderer.ts","webpack:///./src/Projector.ts","webpack:///./src/LinearObjectPool.ts","webpack:///./src/testLevels.ts","webpack:///./src/TileGrid.ts","webpack:///./src/SideReference.ts","webpack:///./src/TileView.ts","webpack:///./src/tickTackToe/TickTackToeTile.ts","webpack:///./src/autoWall.ts","webpack:///./src/WallTile.ts","webpack:///./src/Player.ts","webpack:///./src/Entity.ts","webpack:///./src/ViewCursor.ts","webpack:///./src/Bolt.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","side","deltas","Array","from","length","map","_","delta","y","x","makeDelta","reverseSide","base","args","reduce","dirMtxProductImpl","mtx","dir","det","dirMtxApply","vec","left","right","primary","secondary","window","debug","console","log","__WEBPACK_IMPORTED_MODULE_0__Side__","Cursor","[object Object]","this","mag","dx","dy","nextId","links","id","entities","Set","walkable","tileViews","propertyDominance","Math","random","__WEBPACK_IMPORTED_MODULE_2__TileView__","reciprocate","link","to","unlink","destSide","fromSide","toTile","toSide","__WEBPACK_IMPORTED_MODULE_1__Side__","reflect","addReverse","__WEBPACK_IMPORTED_MODULE_0__SideReference__","fromOpts","onLinked","ctx","t","playerDist","playerShear","loadTimer","entity","add","__WEBPACK_IMPORTED_MODULE_0__Tile__","color","super","stepTime","noiseLevel","render","globalAlpha","pow","fillStyle","fillRect","__WEBPACK_IMPORTED_MODULE_1__opts__","strokeStyle","fns","leftFn","rightFn","__WEBPACK_IMPORTED_MODULE_0__Entity__","width","height","baseTile","gone","trackingTiles","register","out","move","tile","respawn","trackWidth","view","track","renderer","renderHistory","rh","tracker","renderKey","orientation","pt","onEntityX","onEntityY","has","save","applyOrientation","__WEBPACK_IMPORTED_MODULE_1__DirMtx__","translate","__WEBPACK_IMPORTED_MODULE_2__opts__","restore","app","level","__WEBPACK_IMPORTED_MODULE_1__testLevels__","movementKeys","w","a","shootKeys","k","j","PLAYER_SPEED","stepables","vel","__WEBPACK_IMPORTED_MODULE_2__Cursor__","monitorKeys","interactLock","can","document","getElementById","__WEBPACK_IMPORTED_MODULE_0__Renderer__","requestAnimationFrame","nt","tick","onkeydown","e","keyDown","onkeyup","keyUp","ondblclick","requestPointerLock","allEvt","onmousemove","pointerLockElement","abs","movementX","movementY","player","__WEBPACK_IMPORTED_MODULE_4__opts__","__WEBPACK_IMPORTED_MODULE_3__Player__","getView","getNeighbor","cam","center","clone","dt","wat","innerWidth","innerHeight","tryMove","stepable","step","delete","ctr","locCam","copy","stepOn","watNumber","key","interact","performance","now","shoot","shiftKey","maxSquareSquare","z","max","DEBUG","SUPERDebug","TARGET_SIZE","projector","__WEBPACK_IMPORTED_MODULE_0__Projector__","getContext","root","offsetX","offsetY","displayOffsetX","displayOffsetY","scale","items","project","r","sqrt","item","beginPath","rect","clip","moveTo","cos","minTheta","sin","lineTo","maxTheta","stroke","isRoot","anglesLength","fromAng","angles","toAng","sf","lineWidth","translateX","translateY","leftOrientation","topOrientation","cornerDist","cornerShear","fillText","entitiesInit","isOnTile","renderInContext","doTranslate","rotate","PI","reduceAngle","angle","b","reduceAngleCentered","FUDGE_THETA","ANGLE_RANGE","ProjectionPath","Float64Array","centerAngle","atan2","Infinity","ox","oy","theta","addRangeImpl","startIndex","endIndex","startIsOutside","endIsOutside","lengthChange","copyWithin","EDGE_GLITCH_REDUCTION_DIST","lookup","Map","projectionPathPool","__WEBPACK_IMPORTED_MODULE_0__LinearObjectPool__","renderRadiusX","renderRadiusY","displayOffestY","done","que","clear","addRoot","rootPath","pop","init","set","push","shift","considerItem","warn","values","considerSide","axis","offsetZ","nextTile","nextX","nextY","lineZ","topU","bottomU","makeAng","u","projectAng","slopeUZ","tan","colU","newItem","considerAngleRange","newFromAng","newToAng","addRange","foldAngleRange","mid","makeT","size","usedIndex","usedSize","clean","data","makeHubRoom","grid1","__WEBPACK_IMPORTED_MODULE_0__TileGrid__","solidColorTiles","grid2","portSpace","center1","center2","bridge","reverse","__WEBPACK_IMPORTED_MODULE_1__ColorTile__","getReference","ballPort","grid","dynamicColor","mirror","cardinal","isolate","shortWay","S","fastLane","longGrid","shortLength","rain","shortGrid","targ","fastLane2","colorTile","threeTurns","branches","addSide","inner","north","east","west","floor","branches2","tickTackToeLayer","tickTackToeDonut","tickTackToeKlign","tickTackToeMirror","tickTackToeDonutOffset","mobius","len","ot","nextDir","spiral","edgeLength","edge","dest","wheel","__WEBPACK_IMPORTED_MODULE_4__autoWall__","xc","yc","next","h","offset","__WEBPACK_IMPORTED_MODULE_2__compose__","__WEBPACK_IMPORTED_MODULE_3__tickTackToe_TickTackToeTile__","W","H","worlds","forEach","reduceRight","rightTile","rightBridge","worldRoot","hubTile","hubBridge","leftBridge","leftTile","layers","getTiles","tiles","row","SideReference","__WEBPACK_IMPORTED_MODULE_0__DirMtx__","WeakMap","TileView","computeSide","Turn","turnColor","turn","RED","BLACK","TickTackToeGame","won","NONE","blankTiles","MARGIN","singleStepMovement","movement","dirs","movementMethods","TickTackToeTile","__WEBPACK_IMPORTED_MODULE_0__ColorTile__","lengthForWin","occupied","game","isWinningLine","margin","strokeRect","movmentPattern","pair","tallyInDir","drawWinningLine","linkGame","didWin","time","explored","wallsToLink","__WEBPACK_IMPORTED_MODULE_0__WallTile__","timeEnd","wall","nextBase","targWall","wallShade","PERSPECTIVE","fill","PLAYER_SIZE","onScreenSize","__WEBPACK_IMPORTED_MODULE_0__RenderableEntity__","spawnPt","lastMovementDir","bolt","__WEBPACK_IMPORTED_MODULE_2__Bolt__","addStepable","trackHeight","RangeError","trackingTilesOld","trackingPointX","trackingPointY","__WEBPACK_IMPORTED_MODULE_0__ViewCursor__","centerOld","xSide","ySide","xLeft","yLeft","xLocked","yLocked","oPosn","dist","distLeft","maxMovement","newDist","movementUpToEdge","moveWithinTile","crossingValid","thisTracker","tryCrossEdge","outer","tgtView","leftView","topView","ViewCursor","__WEBPACK_IMPORTED_MODULE_0__Cursor__","other","fork","canMove","min","BOLT_SPEED","age","dirPt","stayAlive","kill"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5d0cfe61d4c0506ec9ce","export const TILE_SIZE = 100;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/opts.ts\n// module id = 0\n// module chunks = 0","export const directions = [0 /* right */, 1 /* bottom */, 2 /* left */, 3 /* top */];\r\nfunction makeDelta(i) {\r\n    const delta = i > 1 ? -1 : 1;\r\n    if (i & 1) {\r\n        return { y: delta, x: 0 };\r\n    }\r\n    else {\r\n        return { x: delta, y: 0 };\r\n    }\r\n}\r\nconst deltas = Array.from({ length: 4 }).map((_, i) => makeDelta(i));\r\nexport function getDelta(side) {\r\n    return deltas[side];\r\n}\r\nexport function reverseSide(side) {\r\n    return side ^ 2;\r\n}\r\nexport function getPerpendicularCW(side) {\r\n    return (side + 1) & 3;\r\n}\r\nexport function getPerpendicularCCW(side) {\r\n    return (side + 3) & 3;\r\n}\r\nexport function makePositive(side) {\r\n    return side & 1;\r\n}\r\nexport function getTravel(side) {\r\n    return makePositive(getPerpendicularCW(side));\r\n}\r\nexport function rotate(side, by) {\r\n    return (side + by) & 3;\r\n}\r\nexport function reflect(side, { x, y }) {\r\n    return (side & 1 ? y : x) ? reverseSide(side) : side;\r\n}\r\nexport function invertReflection({ x, y }) {\r\n    return { x: !x, y: !y };\r\n}\r\nexport function mergeReflections({ x, y }, { x: x2, y: y2 }) {\r\n    return {\r\n        x: x !== x2,\r\n        y: y !== y2\r\n    };\r\n}\r\nexport function getOffside(posn) {\r\n    if (posn.x > 1)\r\n        return 0 /* right */;\r\n    if (posn.x < -1)\r\n        return 2 /* left */;\r\n    if (posn.y > 1)\r\n        return 1 /* bottom */;\r\n    if (posn.y < -1)\r\n        return 3 /* top */;\r\n    return -1;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Side.ts\n// module id = 1\n// module chunks = 0","import { getPerpendicularCCW } from './Side';\r\nimport { Cursor } from './Cursor';\r\n// function dirMtxApply(mtx: DirMTX, vec: Side): Side{\r\n//     return (vec & 1 ? ((mtx & 0b11) + ((mtx & 0b100) ? 1 : -1) ) & 0b11 : mtx & 0b11) ^ (vec & 0b10);\r\n// }\r\nexport function dirMtxApply(mtx, vec) {\r\n    return ((mtx & 0b11) + ((mtx & 0b100) ? -vec : vec)) & 0b11;\r\n}\r\nexport function dirMtxProductImpl(left, right) {\r\n    const primary = dirMtxApply(left, dirMtxApply(right, 0));\r\n    const secondary = dirMtxApply(left, dirMtxApply(right, 1));\r\n    if (window.debug)\r\n        console.log(primary, secondary);\r\n    return primary | (getPerpendicularCCW(primary) === secondary ? 0b100 : 0);\r\n}\r\nexport function dirMtxProduct(base, ...args) {\r\n    return args.reduce(dirMtxProductImpl, base);\r\n}\r\nexport function dirMtxInverse(mtx) {\r\n    return (mtx & 0b100) ? mtx : (-mtx) & 0b11;\r\n}\r\nexport function makeDirMtx(dir, det) {\r\n    return det ? (dir & 0b11) | 0b100 : dir & 0b11;\r\n}\r\nexport function dirMtxApplyPt(mtx, pt) {\r\n    return new Cursor({ x: 0, y: 0 }).step(dirMtxApply(mtx, 0 /* right */), pt.x).step(dirMtxApply(mtx, 1 /* bottom */), pt.y);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/DirMtx.ts\n// module id = 2\n// module chunks = 0","import { getDelta } from \"./Side\";\r\nexport class Cursor {\r\n    constructor(p) {\r\n        this.x = p.x;\r\n        this.y = p.y;\r\n    }\r\n    step(side, mag = 1) {\r\n        const { x: dx, y: dy } = getDelta(side);\r\n        this.x += dx * mag;\r\n        this.y += dy * mag;\r\n        return this;\r\n    }\r\n    fork() {\r\n        return new Cursor(this);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Cursor.ts\n// module id = 3\n// module chunks = 0","import { SideReference } from './SideReference';\r\nimport { reverseSide } from './Side';\r\nimport { TileView } from './TileView';\r\nlet nextId = 0;\r\nexport class Tile {\r\n    constructor() {\r\n        this.links = [null, null, null, null];\r\n        this.id = nextId++;\r\n        this.entities = new Set();\r\n        this.walkable = true;\r\n        this.tileViews = Array(8);\r\n        this.propertyDominance = Math.random();\r\n        for (let i = 0; i < 8; i++) {\r\n            this.tileViews[i] = new TileView(this, i);\r\n        }\r\n    }\r\n    getReference(i) {\r\n        return this.links[i];\r\n    }\r\n    unlink(i, reciprocate = true) {\r\n        if (this.links[i]) {\r\n            const link = this.links[i];\r\n            if (reciprocate) {\r\n                link.to.unlink(link.destSide, false);\r\n            }\r\n            this.links[i] = null;\r\n        }\r\n    }\r\n    link(fromSide, toTile, toSide = reverseSide(fromSide), { reflect = false, addReverse = true } = {}) {\r\n        this.unlink(fromSide);\r\n        this.links[fromSide] = SideReference.fromOpts(toTile, fromSide, toSide, reflect);\r\n        if (addReverse) {\r\n            toTile.link(toSide, this, fromSide, {\r\n                addReverse: false,\r\n                reflect\r\n            });\r\n        }\r\n        this.onLinked(this.links[fromSide]);\r\n    }\r\n    onLinked(side) {\r\n    }\r\n    getView(mtx) {\r\n        return this.tileViews[mtx];\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        this.loadTimer = t;\r\n    }\r\n    isolate() {\r\n        for (let i = 0; i < 4; i++) {\r\n            this.unlink(i);\r\n        }\r\n    }\r\n    stepOn(t) {\r\n    }\r\n    interact(t) {\r\n    }\r\n    track(entity) {\r\n        this.entities.add(entity);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Tile.ts\n// module id = 4\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nexport class ColorTile extends Tile {\r\n    constructor(color) {\r\n        super();\r\n        this.stepTime = 0;\r\n        this.color = color;\r\n        this.noiseLevel = 1 - Math.random() * 0.2;\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        super.render(ctx, t, playerDist, playerShear);\r\n        ctx.globalAlpha = (1 - Math.pow(2, (this.stepTime - t) / 1000) / 3) * this.noiseLevel;\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\r\n        ctx.globalAlpha = 1;\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n    stepOn(t) {\r\n        this.stepTime = t;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ColorTile.ts\n// module id = 5\n// module chunks = 0","export function strictCompose(fns) {\r\n    return fns.reduce((leftFn, rightFn) => (x) => leftFn(rightFn(x)), x => x);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/compose.ts\n// module id = 6\n// module chunks = 0","import { Entity } from \"./Entity\";\r\nimport { dirMtxInverse } from \"./DirMtx\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nexport class RenderableEntity extends Entity {\r\n    constructor(width, height, baseTile) {\r\n        super(width, height, baseTile);\r\n        this.gone = false;\r\n        console.log(this.trackingTiles);\r\n        this.register();\r\n    }\r\n    move(dx, dy) {\r\n        const out = super.move(dx, dy);\r\n        this.register();\r\n        return out;\r\n    }\r\n    respawn(tile) {\r\n        super.respawn(tile);\r\n        this.register();\r\n    }\r\n    render(ctx) {\r\n    }\r\n    kill() {\r\n        this.gone = true;\r\n    }\r\n    isOnTile(tile) {\r\n        if (this.gone)\r\n            return false;\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                if (this.trackingTiles[x][y].view.tile.id === tile.id) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    register() {\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                this.trackingTiles[x][y].view.track(this);\r\n            }\r\n        }\r\n    }\r\n    renderInContext(renderer, tile) {\r\n        const renderHistory = new Set();\r\n        window.rh = renderHistory;\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            for (let y = 0; y < this.trackWidth; y++) {\r\n                const tracker = this.trackingTiles[x][y];\r\n                if (tracker.view.tile === tile) {\r\n                    const renderKey = `${tracker.view.orientation}/${tracker.pt.x - tracker.onEntityX}/${tracker.pt.y - tracker.onEntityY}`;\r\n                    if (!renderHistory.has(renderKey)) {\r\n                        renderHistory.add(renderKey);\r\n                        renderer.ctx.save();\r\n                        renderer.applyOrientation(dirMtxInverse(tracker.view.orientation));\r\n                        renderer.ctx.translate((tracker.pt.x - tracker.onEntityX) * TILE_SIZE, (tracker.pt.y - tracker.onEntityY) * TILE_SIZE);\r\n                        this.render(renderer.ctx);\r\n                        renderer.ctx.restore();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RenderableEntity.ts\n// module id = 7\n// module chunks = 0","import { App } from \"./App\";\r\nconst app = new App();\r\nwindow.app = app;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 8\n// module chunks = 0","import { Renderer } from \"./Renderer\";\r\nimport * as testLevels from './testLevels';\r\nimport { Cursor } from \"./Cursor\";\r\nimport { Player } from \"./Player\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst level = testLevels.hubRoom();\r\nconst movementKeys = {\r\n    w: 3 /* top */,\r\n    a: 2 /* left */,\r\n    s: 1 /* bottom */,\r\n    d: 0 /* right */\r\n};\r\nconst shootKeys = {\r\n    i: 3 /* top */,\r\n    l: 0 /* right */,\r\n    k: 1 /* bottom */,\r\n    j: 2 /* left */\r\n};\r\nconst PLAYER_SPEED = 5 / 1000;\r\nexport class App {\r\n    constructor() {\r\n        this.stepables = new Set();\r\n        this.vel = new Cursor({ x: 0, y: 0 });\r\n        this.monitorKeys = {\r\n            w: false,\r\n            a: false,\r\n            s: false,\r\n            d: false\r\n        };\r\n        this.interactLock = false;\r\n        this.can = document.getElementById(\"can\");\r\n        this.renderer = new Renderer(this.can);\r\n        requestAnimationFrame(t => requestAnimationFrame((nt) => this.tick(nt, nt - t, Math.random())));\r\n        document.onkeydown = (e) => {\r\n            this.keyDown(e);\r\n        };\r\n        document.onkeyup = (e) => {\r\n            this.keyUp(e);\r\n        };\r\n        this.can.ondblclick = (e) => {\r\n            this.can.requestPointerLock();\r\n            this.allEvt(e);\r\n        };\r\n        this.can.onmousemove = (e) => {\r\n            if (document.pointerLockElement === this.can) {\r\n                if (Math.abs(e.movementX) < 200 && Math.abs(e.movementY) < 200)\r\n                    this.player.move(e.movementX / TILE_SIZE, e.movementY / TILE_SIZE);\r\n            }\r\n            this.allEvt(e);\r\n        };\r\n        this.player = new Player(level.getView(0).getNeighbor(0 /* right */), this);\r\n        this.cam = this.player.center.clone();\r\n    }\r\n    tick(t, dt, wat) {\r\n        if (this.can.width !== innerWidth || this.can.height !== innerHeight) {\r\n            this.can.width = innerWidth;\r\n            this.can.height = innerHeight;\r\n        }\r\n        this.tryMove(dt);\r\n        for (let stepable of this.stepables) {\r\n            if (!stepable.step(dt)) {\r\n                this.stepables.delete(stepable);\r\n            }\r\n        }\r\n        const ctr = this.locCam || this.player.center;\r\n        this.cam.copy(ctr);\r\n        const offsetX = 0;\r\n        const offsetY = 0;\r\n        ctr.view.stepOn(t);\r\n        if (!this.cam.move(offsetX, offsetY)) {\r\n            console.log(\"wat\");\r\n        }\r\n        this.renderer.render(this.cam.view, this.cam.pt.x, this.cam.pt.y, t, offsetX, offsetY);\r\n        if (this.watNumber !== wat)\r\n            console.log('wat');\r\n        this.watNumber = wat;\r\n        requestAnimationFrame((nt) => this.tick(nt, nt - t, wat));\r\n    }\r\n    keyDown(e) {\r\n        if (e.key in this.monitorKeys) {\r\n            this.monitorKeys[e.key] = true;\r\n        }\r\n        if (e.key === \"e\" && !this.interactLock) {\r\n            this.interactLock = true;\r\n            this.player.center.view.interact(performance.now());\r\n        }\r\n        if (e.key in shootKeys) {\r\n            this.player.shoot(shootKeys[e.key]);\r\n        }\r\n        this.allEvt(e);\r\n    }\r\n    allEvt(e) {\r\n        if (e.shiftKey && !this.locCam) {\r\n            this.locCam = this.player.center.clone();\r\n        }\r\n        if (!e.shiftKey) {\r\n            this.locCam = null;\r\n        }\r\n    }\r\n    keyUp(e) {\r\n        if (e.key in this.monitorKeys) {\r\n            this.monitorKeys[e.key] = false;\r\n        }\r\n        if (e.key === \"e\") {\r\n            this.interactLock = false;\r\n        }\r\n        if (e.key === \"h\") {\r\n            this.player.respawn(level.getView(0));\r\n        }\r\n        this.allEvt(e);\r\n    }\r\n    tryMove(dt) {\r\n        this.vel.x = 0;\r\n        this.vel.y = 0;\r\n        for (let key in movementKeys) {\r\n            if (this.monitorKeys[key]) {\r\n                this.vel.step(movementKeys[key], PLAYER_SPEED * dt);\r\n            }\r\n        }\r\n        if (this.vel.x !== 0 || this.vel.y !== 0) {\r\n            this.player.move(this.vel.x, this.vel.y);\r\n        }\r\n        // if(this.posn.x > 1){\r\n        //     if(!this.tryStep(Side.right)){\r\n        //         this.posn.x = 1\r\n        //     }\r\n        // }\r\n        // if (this.posn.y > 1) {\r\n        //     if (!this.tryStep(Side.bottom)) {\r\n        //         this.posn.y = 1;\r\n        //     }\r\n        // }\r\n        // if (this.posn.x < 0) {\r\n        //     if (!this.tryStep(Side.left)) {\r\n        //         this.posn.x = 0;\r\n        //     }\r\n        // }\r\n        // if (this.posn.y < 0) {\r\n        //     if (!this.tryStep(Side.top)) {\r\n        //         this.posn.y = 0;\r\n        //     }\r\n        // }\r\n    }\r\n    // tryStep(dir: Side){\r\n    //     if(this.view.getNeighbor(dir)){\r\n    //         this.view = this.view.getNeighbor(dir);\r\n    //         this.posn.step(dir,-1);\r\n    //         return true;\r\n    //     }\r\n    //     return false;\r\n    // }\r\n    addStepable(stepable) {\r\n        this.stepables.add(stepable);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.ts\n// module id = 9\n// module chunks = 0","import { Projector } from \"./Projector\";\r\nimport { dirMtxApply } from \"./DirMtx\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nfunction maxSquareSquare(z) {\r\n    return Math.max(z ** 2, (z + 1) ** 2);\r\n}\r\nconst debugColors = ['red', 'green', 'blue', 'cyan', 'orange'];\r\nfunction debugColor() {\r\n    return debugColors[(Math.random() * debugColors.length) | 0];\r\n}\r\nconst DEBUG = false;\r\nconst SUPERDebug = false;\r\nconst TARGET_SIZE = 12;\r\n// const DEBUGMAP = {7:true, 3:true};\r\nexport class Renderer {\r\n    constructor(can) {\r\n        this.projector = new Projector();\r\n        this.can = can;\r\n        this.ctx = can.getContext('2d');\r\n    }\r\n    render(root, offsetX, offsetY, t, displayOffsetX, displayOffsetY) {\r\n        const scale = this.scale = 1 / Math.max(TILE_SIZE * TARGET_SIZE / this.can.width, TILE_SIZE * TARGET_SIZE / this.can.height);\r\n        const items = this.projector.project(root, offsetX, offsetY, this.can.width / TILE_SIZE / 2 / scale, this.can.height / TILE_SIZE / 2 / scale, displayOffsetX, displayOffsetY);\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.fillRect(0, 0, this.can.width, this.can.height);\r\n        this.ctx.save();\r\n        this.ctx.translate(this.can.width / 2, this.can.height / 2);\r\n        this.ctx.scale(scale, scale);\r\n        this.ctx.translate((displayOffsetX * TILE_SIZE), (displayOffsetY * TILE_SIZE));\r\n        // this.ctx.scale(TILE_SIZE, TILE_SIZE);\r\n        const r = Math.sqrt(maxSquareSquare(this.can.width + offsetX * TILE_SIZE) +\r\n            maxSquareSquare(this.can.height + offsetY * TILE_SIZE)) / 2;\r\n        for (let item of items) {\r\n            // if (DEBUG) console.log(item);\r\n            this.ctx.save();\r\n            if (SUPERDebug) {\r\n                if ((item.x !== 0 || item.y !== -2)) {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.rect((item.x - offsetX) * TILE_SIZE, (item.y - offsetY) * TILE_SIZE, TILE_SIZE, TILE_SIZE);\r\n                    this.ctx.clip();\r\n                }\r\n                else {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.moveTo(1000 * Math.cos(item.minTheta), 1000 * Math.sin(item.minTheta));\r\n                    this.ctx.lineTo(0, 0);\r\n                    this.ctx.lineTo(1000 * Math.cos(item.maxTheta), 1000 * Math.sin(item.maxTheta));\r\n                    this.ctx.strokeStyle = 'orange';\r\n                    this.ctx.stroke();\r\n                }\r\n            }\r\n            if (!item.isRoot && item.anglesLength !== 2) {\r\n                this.ctx.beginPath();\r\n                for (let i = 0; i < item.anglesLength; i += 2) {\r\n                    const fromAng = item.angles[i];\r\n                    const toAng = item.angles[i + 1];\r\n                    if (fromAng === toAng)\r\n                        continue;\r\n                    const sf = Math.abs(1 / Math.cos((fromAng - toAng) / 2));\r\n                    this.ctx.moveTo(0, 0);\r\n                    this.ctx.lineTo(Math.cos(fromAng) * r * sf, Math.sin(fromAng) * r * sf);\r\n                    // this.ctx.arc(0, 0, r * TILE_SIZE, fromAng, toAng);\r\n                    this.ctx.lineTo(Math.cos(toAng) * r * sf, Math.sin(toAng) * r * sf);\r\n                    this.ctx.lineTo(0, 0);\r\n                }\r\n                if (DEBUG) {\r\n                    this.ctx.lineWidth = 1;\r\n                    this.ctx.strokeStyle = \"pink\";\r\n                    this.ctx.stroke();\r\n                }\r\n                this.ctx.clip();\r\n            }\r\n            const translateX = ((item.x - offsetX) * TILE_SIZE);\r\n            const translateY = ((item.y - offsetY) * TILE_SIZE);\r\n            this.ctx.translate(translateX, translateY);\r\n            this.applyOrientation(item.view.orientation);\r\n            const leftOrientation = dirMtxApply(item.view.orientation, 2 /* left */);\r\n            const topOrientation = dirMtxApply(item.view.orientation, 3 /* top */);\r\n            // this.ctx.beginPath();\r\n            // this.ctx.rect(0, 0, 1, 1);\r\n            // this.ctx.clip();\r\n            const cornerDist = (leftOrientation & 0b1 ? translateY : translateX);\r\n            const cornerShear = (topOrientation & 0b1 ? translateY : translateX);\r\n            item.view.tile.render(this.ctx, t, leftOrientation & 0b10 ? cornerDist : (-TILE_SIZE - cornerDist), topOrientation & 0b10 ? cornerShear : (-TILE_SIZE - cornerShear));\r\n            if (DEBUG) {\r\n                this.ctx.fillStyle = \"black\";\r\n                this.ctx.fillText(`${item.view.id}`, 10, 10);\r\n            }\r\n            let entitiesInit = false;\r\n            const tile = item.view.tile;\r\n            for (let entity of item.view.tile.entities) {\r\n                const isOnTile = entity.isOnTile(item.view.tile);\r\n                if (!isOnTile) {\r\n                    tile.entities.delete(entity);\r\n                }\r\n                else {\r\n                    if (!entitiesInit) {\r\n                        this.ctx.beginPath();\r\n                        this.ctx.rect(0, 0, TILE_SIZE, TILE_SIZE);\r\n                        this.ctx.clip();\r\n                        entitiesInit = true;\r\n                    }\r\n                    entity.renderInContext(this, item.view.tile);\r\n                }\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n        // this.ctx.beginPath();\r\n        // this.ctx.fillStyle = 'black';\r\n        // this.ctx.arc(0, 0, TILE_SIZE / 3, 0, Math.PI * 2);\r\n        // this.ctx.fill();\r\n        this.ctx.restore();\r\n        // this.ctx.beginPath();\r\n        // for (let x = (this.can.width / 2 - offsetX * TILE_SIZE) % TILE_SIZE - TILE_SIZE; x < this.can.width; x += TILE_SIZE) {\r\n        //     this.ctx.moveTo(x, 0);\r\n        //     this.ctx.lineTo(x, this.can.height);\r\n        // }\r\n        // for (let y = (this.can.height / 2 - offsetY * TILE_SIZE) % TILE_SIZE - TILE_SIZE; y < this.can.height; y += TILE_SIZE) {\r\n        //     this.ctx.moveTo(0, y);\r\n        //     this.ctx.lineTo(this.can.width, y);\r\n        // }    \r\n        // this.ctx.strokeStyle = 'rgba(255,255,255,1)';\r\n        // this.ctx.lineWidth = 1;\r\n        // this.ctx.stroke();\r\n    }\r\n    applyOrientation(orientation, doTranslate = true) {\r\n        const { ctx } = this;\r\n        if (doTranslate)\r\n            this.ctx.translate(0.5 * TILE_SIZE, 0.5 * TILE_SIZE);\r\n        ctx.rotate((orientation & 0b11) * Math.PI / 2);\r\n        if (orientation & 0b100)\r\n            ctx.scale(1, -1);\r\n        if (doTranslate)\r\n            this.ctx.translate(-0.5 * TILE_SIZE, -0.5 * TILE_SIZE);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Renderer.ts\n// module id = 10\n// module chunks = 0","import { LinearObjectPool } from \"./LinearObjectPool\";\r\nfunction trueMod(a, b) {\r\n    return ((a % b) + b) % b;\r\n}\r\nfunction reduceAngle(angle) {\r\n    return trueMod(angle + Math.PI, Math.PI * 2) - Math.PI;\r\n}\r\nfunction reduceAngleCentered(center, angle) {\r\n    return reduceAngle(angle - center) + center;\r\n}\r\nconst FUDGE_THETA = Math.PI / 100000;\r\nfunction greaterThanEqualsFavorsTrue(a, b) {\r\n    return a + FUDGE_THETA >= b;\r\n}\r\nconst DEBUG = false;\r\nconst ANGLE_RANGE = Math.PI / 100000;\r\nclass ProjectionPath {\r\n    constructor() {\r\n        this.angles = new Float64Array(32);\r\n        this.anglesLength = 0;\r\n    }\r\n    static id(view, x, y) {\r\n        return `${view.id},${x},${y}`;\r\n    }\r\n    init(view, x, y, isRoot = false, offsetX, offsetY) {\r\n        this.view = view;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.anglesLength = 0;\r\n        this.centerAngle = Math.atan2(y, x);\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        if (isRoot) {\r\n            //    this.angles.push(\r\n            //        0,\r\n            //        Math.PI / 2\r\n            //    );\r\n            for (let i = 0; i < 3; i++) {\r\n                this.angles[this.anglesLength++] = (Math.PI * 2 / 3 * (i + .5));\r\n                this.angles[this.anglesLength++] = (Math.PI * 2 / 3 * (i + 1.5));\r\n            }\r\n        }\r\n        else {\r\n            let minTheta = Infinity;\r\n            let maxTheta = -Infinity;\r\n            for (let ox = 0; ox < 2; ox++) {\r\n                for (let oy = 0; oy < 2; oy++) {\r\n                    const theta = reduceAngleCentered(this.centerAngle, Math.atan2(y - offsetY + oy, x - offsetX + ox));\r\n                    if (theta < minTheta)\r\n                        minTheta = theta;\r\n                    if (theta > maxTheta)\r\n                        maxTheta = theta;\r\n                }\r\n            }\r\n            this.minTheta = minTheta;\r\n            this.maxTheta = maxTheta;\r\n            this.angles[this.anglesLength++] = minTheta;\r\n            this.angles[this.anglesLength++] = minTheta;\r\n            this.angles[this.anglesLength++] = maxTheta;\r\n            this.angles[this.anglesLength++] = maxTheta;\r\n        }\r\n        this.id = ProjectionPath.id(view, x, y);\r\n        this.isRoot = isRoot;\r\n        return this;\r\n    }\r\n    addRange(from, to) {\r\n        this.addRangeImpl(reduceAngleCentered(this.centerAngle, from), reduceAngleCentered(this.centerAngle, to));\r\n    }\r\n    addRangeImpl(from, to) {\r\n        if (this.isRoot)\r\n            return;\r\n        if (DEBUG)\r\n            console.log('adding range', this.id, from, to);\r\n        if (to === from) {\r\n            return;\r\n        }\r\n        if (to < from) {\r\n            // console.log(to, from);\r\n            this.addRangeImpl(to, from);\r\n            return;\r\n        }\r\n        let startIndex = 0;\r\n        for (; startIndex < this.angles.length; startIndex++) {\r\n            if (startIndex % 2 === 1 ?\r\n                this.angles[startIndex] + FUDGE_THETA >= from\r\n                : this.angles[startIndex] >= from + FUDGE_THETA) {\r\n                break;\r\n            }\r\n        }\r\n        let endIndex = startIndex;\r\n        for (; endIndex < this.angles.length; endIndex++) {\r\n            if (endIndex % 2 === 1 ?\r\n                this.angles[endIndex] + FUDGE_THETA > to\r\n                : this.angles[endIndex] > FUDGE_THETA + to) {\r\n                break;\r\n            }\r\n        }\r\n        const startIsOutside = startIndex % 2 == 0;\r\n        const endIsOutside = endIndex % 2 == 0;\r\n        const lengthChange = startIndex - endIndex + (startIsOutside ? 1 : 0) + (endIsOutside ? 1 : 0);\r\n        this.angles.copyWithin(endIndex + lengthChange, endIndex, this.anglesLength);\r\n        this.anglesLength += lengthChange;\r\n        if (startIsOutside)\r\n            this.angles[startIndex++] = from;\r\n        if (endIsOutside)\r\n            this.angles[startIndex++] = to;\r\n        // if (startIsOutside && endIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, from, to);\r\n        // } else if (startIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, from);\r\n        // } else if (endIsOutside) {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex, to);\r\n        // } else {\r\n        //     this.angles.splice(startIndex, endIndex - startIndex);\r\n        // }\r\n        return;\r\n    }\r\n    clean() {\r\n        this.view = null; //this ref could be very costly\r\n    }\r\n}\r\nconst EDGE_GLITCH_REDUCTION_DIST = 1 / 100000;\r\nexport class Projector {\r\n    constructor() {\r\n        this.lookup = new Map();\r\n        this.projectionPathPool = new LinearObjectPool(() => new ProjectionPath());\r\n    }\r\n    project(root, offsetX, offsetY, renderRadiusX, renderRadiusY, displayOffsetX, displayOffestY) {\r\n        this.projectionPathPool.done();\r\n        this.que = [];\r\n        this.lookup.clear();\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        this.renderRadiusX = renderRadiusX;\r\n        this.renderRadiusY = renderRadiusY;\r\n        this.displayOffsetX = displayOffsetX;\r\n        this.displayOffsetY = displayOffestY;\r\n        const addRoot = (root, x, y) => {\r\n            if (!root)\r\n                return;\r\n            if (x === 0 && y === 0) {\r\n                if (offsetX <= EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(2 /* left */), -1, y);\r\n                }\r\n                if (offsetX >= 1 - EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(0 /* right */), 1, y);\r\n                }\r\n                if (offsetY <= EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(3 /* top */), x, -1);\r\n                }\r\n                if (offsetY >= 1 - EDGE_GLITCH_REDUCTION_DIST) {\r\n                    addRoot(root.getNeighbor(1 /* bottom */), x, 1);\r\n                }\r\n            }\r\n            const rootPath = this.projectionPathPool.pop().init(root, x, y, true, offsetX, offsetY);\r\n            this.lookup.set(rootPath.id, rootPath);\r\n            this.que.push(rootPath);\r\n        };\r\n        addRoot(root, 0, 0);\r\n        while (this.que.length > 0) {\r\n            const item = this.que.shift();\r\n            this.considerItem(item);\r\n            if (this.que.length > 1000) {\r\n                console.warn('oversize que');\r\n                break;\r\n            }\r\n        }\r\n        return this.lookup.values();\r\n    }\r\n    considerItem(item) {\r\n        if (Math.sqrt(item.x ** 2 + item.y ** 2) > 100)\r\n            return;\r\n        if (item.x >= 0 || item.isRoot)\r\n            this.considerSide(item, true, 1, item.view.getNeighbor(0), item.x + 1, item.y);\r\n        if (item.y >= 0 || item.isRoot)\r\n            this.considerSide(item, false, 1, item.view.getNeighbor(1), item.x, item.y + 1);\r\n        if (item.x < 1 || item.isRoot)\r\n            this.considerSide(item, true, 0, item.view.getNeighbor(2), item.x - 1, item.y);\r\n        if (item.y < 1 || item.isRoot)\r\n            this.considerSide(item, false, 0, item.view.getNeighbor(3), item.x, item.y - 1);\r\n    }\r\n    /**\r\n     *\r\n     * @param axis true = line goes up down\r\n     */\r\n    considerSide(item, axis, offsetZ, nextTile, nextX, nextY) {\r\n        if (nextX - this.offsetX + this.displayOffsetX > this.renderRadiusX ||\r\n            nextX - this.offsetX + 1 + this.displayOffsetX < -this.renderRadiusX ||\r\n            nextY - this.offsetY + this.displayOffsetY > this.renderRadiusY ||\r\n            nextY - this.offsetY + 1 + this.displayOffsetY < -this.renderRadiusY)\r\n            return;\r\n        if (!nextTile)\r\n            return;\r\n        if (DEBUG)\r\n            console.log(\"consider side\", axis, offsetZ, nextTile, nextX, nextY, item.id);\r\n        const lineZ = axis ? item.x + offsetZ - this.offsetX : item.y + offsetZ - this.offsetY;\r\n        const topU = axis ? item.y - this.offsetY : item.x - this.offsetX;\r\n        const bottomU = topU + 1;\r\n        function makeAng(u) {\r\n            return axis ? Math.atan2(u, lineZ) : -Math.atan2(u, lineZ) + Math.PI / 2;\r\n        }\r\n        function projectAng(angle) {\r\n            if (Math.abs(reduceAngle(angle + (axis ? Math.PI / 2 : Math.PI))) < ANGLE_RANGE) {\r\n                return makeAng(topU);\r\n            }\r\n            else if (Math.abs(reduceAngle(angle + (axis ? Math.PI / 2 : 0))) < ANGLE_RANGE) {\r\n                return makeAng(bottomU);\r\n            }\r\n            const slopeUZ = axis ? Math.tan(angle) : Math.tan(Math.PI / 2 - angle);\r\n            const colU = slopeUZ * lineZ;\r\n            if (DEBUG)\r\n                console.log(\"proj\", angle, slopeUZ, colU);\r\n            if ((axis ? Math.cos(angle) : Math.sin(angle)) * lineZ < 0) {\r\n                // return projectAng(-angle);\r\n                return (!axis ? Math.cos(angle) : Math.sin(angle)) < 0 ? makeAng(topU) : makeAng(bottomU);\r\n            }\r\n            if (colU < topU) {\r\n                return makeAng(topU);\r\n            }\r\n            else if (colU > bottomU) {\r\n                return makeAng(bottomU);\r\n            }\r\n            else {\r\n                return angle;\r\n            }\r\n        }\r\n        let newItem = null;\r\n        const considerAngleRange = (fromAng, toAng) => {\r\n            const newFromAng = projectAng(fromAng);\r\n            const newToAng = projectAng(toAng);\r\n            if (DEBUG)\r\n                console.log(\"proj section\", item.id, fromAng, toAng, newFromAng, newToAng);\r\n            if (newFromAng === false || newToAng === false) {\r\n                return;\r\n            }\r\n            if (newFromAng !== newToAng) {\r\n                if (newItem === null) {\r\n                    const key = ProjectionPath.id(nextTile, nextX, nextY);\r\n                    if (this.lookup.has(key)) {\r\n                        newItem = this.lookup.get(key);\r\n                    }\r\n                    else {\r\n                        newItem = this.projectionPathPool.pop();\r\n                        newItem.init(nextTile, nextX, nextY, false, this.offsetX, this.offsetY);\r\n                        this.lookup.set(key, newItem);\r\n                        this.que.push(newItem);\r\n                    }\r\n                }\r\n                newItem.addRange(newFromAng, newToAng);\r\n            }\r\n        };\r\n        const foldAngleRange = (fromAng, toAng) => {\r\n            if (Math.abs(reduceAngle(toAng - fromAng)) > Math.PI / 2) {\r\n                const mid = reduceAngle((fromAng + toAng) / 2);\r\n                considerAngleRange(reduceAngle(fromAng), mid);\r\n                considerAngleRange(mid, reduceAngle(toAng));\r\n                return;\r\n            }\r\n            else {\r\n                considerAngleRange(reduceAngle(fromAng), reduceAngle(toAng));\r\n            }\r\n        };\r\n        for (let i = 0; i < item.anglesLength / 2; i++) {\r\n            const fromAng = item.angles[2 * i];\r\n            const toAng = item.angles[2 * i + 1];\r\n            if (fromAng === toAng)\r\n                continue;\r\n            foldAngleRange(fromAng, toAng);\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Projector.ts\n// module id = 11\n// module chunks = 0","export class LinearObjectPool {\r\n    constructor(makeT, size = 64) {\r\n        this.usedIndex = 0;\r\n        this.makeT = makeT;\r\n        this.items = [...Array(size)].map(() => makeT());\r\n    }\r\n    pop() {\r\n        if (this.usedIndex + 1 >= this.items.length) {\r\n            this.items.push(this.makeT());\r\n            window.usedSize = this.items.length;\r\n        }\r\n        return this.items[this.usedIndex++];\r\n    }\r\n    done() {\r\n        for (let i = this.usedIndex; i >= 0; i--) {\r\n            this.items[i].clean();\r\n        }\r\n        this.usedIndex = 0;\r\n    }\r\n    clean() {\r\n        this.done();\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/LinearObjectPool.ts\n// module id = 12\n// module chunks = 0","import { TileGrid } from \"./TileGrid\";\r\nimport { ColorTile } from \"./ColorTile\";\r\nimport { strictCompose } from \"./compose\";\r\nimport { TickTackToeTile } from \"./tickTackToe/TickTackToeTile\";\r\nimport { autoWall } from \"./autoWall\";\r\nfunction colorTile(xc, yc, color) {\r\n    return (next) => (x, y) => {\r\n        if (x === xc && y === yc) {\r\n            return new ColorTile(color);\r\n        }\r\n        return next(x, y);\r\n    };\r\n}\r\nfunction dynamicColor(w, h, base = 255) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(`rgb(${((x / w) ** .5 * 255) | 0},${base},${((y / h) ** .5 * 255) | 0})`);\r\n    };\r\n}\r\nfunction rain(sf, offset = 0) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(`hsl(${(((x + offset) / sf) * 360) | 0},50%,50%)`);\r\n    };\r\n}\r\nfunction checkers(...colors) {\r\n    return (next) => (x, y) => {\r\n        return new ColorTile(colors[(x + y) % colors.length]);\r\n    };\r\n}\r\nfunction cardinal(xc, yc) {\r\n    return strictCompose([\r\n        colorTile(xc + 1, yc, 'red'),\r\n        colorTile(xc, yc + 1, 'green'),\r\n        colorTile(xc - 1, yc, 'blue'),\r\n        colorTile(xc, yc - 1, 'cyan')\r\n    ]);\r\n}\r\nfunction tickTackToeLayer(n = 3) {\r\n    return (next) => (x, y) => {\r\n        return new TickTackToeTile(n);\r\n    };\r\n}\r\nfunction fullColor(color) {\r\n    return solidColorTiles(color);\r\n}\r\nfunction solidColorTiles(color) {\r\n    return (next) => (x, y) => new ColorTile(color);\r\n}\r\nexport function flatSpace() {\r\n    const grid = new TileGrid(9, 9);\r\n    grid.get(2, 1).isolate();\r\n    return grid.get(1, 1);\r\n}\r\nexport function portSpace() {\r\n    const grid1 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"red\")\r\n    ]);\r\n    const grid2 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"blue\")\r\n    ]);\r\n    grid1.get(4, 4).link(0 /* right */, grid2.get(4, 4));\r\n    grid2.get(8, 8).link(1 /* bottom */, grid1.get(0, 0));\r\n    grid2.get(6, 4).link(0 /* right */, grid1.get(2, 4));\r\n    return grid1.get(4, 7);\r\n}\r\nexport function shortWay() {\r\n    const grid = new TileGrid(11, 5, [\r\n        cardinal(5, 2),\r\n        dynamicColor(10, 5)\r\n    ]);\r\n    for (let i = 2; i < 9; i++) {\r\n        grid.get(i, 2).isolate();\r\n    }\r\n    for (let i = 0; i < 2; i++) {\r\n        grid.get(1, i).link(0 /* right */, grid.get(8, i));\r\n    }\r\n    return grid.get(0, 4);\r\n}\r\nexport function threeTurns() {\r\n    const grid = new TileGrid(7, 7, [\r\n        cardinal(2, 2),\r\n        colorTile(0, 0, 'pink'),\r\n        dynamicColor(7, 7)\r\n    ]);\r\n    for (let i = 0; i < 7; i++) {\r\n        if (i === 1 || i === 5) {\r\n            continue;\r\n        }\r\n        grid.get(i, 3).isolate();\r\n        grid.get(3, i).isolate();\r\n    }\r\n    grid.get(3, 5).link(0 /* right */, grid.get(5, 2), 1 /* bottom */);\r\n    return grid.get(2, 2);\r\n}\r\nexport function bridge() {\r\n    const grid = new TileGrid(5, 5, [\r\n        cardinal(2, 2),\r\n        dynamicColor(5, 5)\r\n    ]);\r\n    const bridge = new ColorTile('orange');\r\n    console.log(grid);\r\n    grid.get(0, 0).link(3 /* top */, bridge);\r\n    grid.get(4, 0).link(3 /* top */, bridge, 3 /* top */, { reflect: true });\r\n    grid.get(4, 4).link(0 /* right */, bridge);\r\n    return grid.get(2, 2);\r\n}\r\nexport function fastLane() {\r\n    const S = 27;\r\n    const grid = new TileGrid(S, 4, [\r\n        dynamicColor(S, 4)\r\n    ]);\r\n    for (let i = 0; i < S; i += 2) {\r\n        for (let j = 0; j < 2; j++) {\r\n            if (i < S - 2)\r\n                grid.get(i, j).link(0 /* right */, grid.get(i + 2, j));\r\n            if (i < S - 1)\r\n                grid.get(i + 1, j).isolate();\r\n        }\r\n    }\r\n    return grid.get(0, 3);\r\n}\r\nexport function fastLane2() {\r\n    const shortLength = 10;\r\n    const zoomLevel = 5;\r\n    const longGrid = new TileGrid(shortLength * zoomLevel, 2, [\r\n        rain(shortLength * zoomLevel / 3)\r\n    ]);\r\n    for (let o = 0; o < zoomLevel; o++) {\r\n        const shortGrid = new TileGrid(shortLength, 2, [\r\n            rain(shortLength / 3, o / zoomLevel)\r\n        ]);\r\n        for (let i = 0; i < shortLength; i++) {\r\n            const targ = longGrid.get(i * zoomLevel + o, 0);\r\n            shortGrid.get(i, 1).link(1 /* bottom */, targ);\r\n        }\r\n    }\r\n    return longGrid.get(0, 1);\r\n}\r\nexport function ballPort() {\r\n    const grid1 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"red\")\r\n    ]);\r\n    const grid2 = new TileGrid(9, 9, [\r\n        solidColorTiles(\"blue\")\r\n    ]);\r\n    const center1 = grid1.get(4, 4);\r\n    const center2 = grid2.get(4, 4);\r\n    let bridge;\r\n    for (let i = 0; i < 4; i++) {\r\n        const reverse = (i + 2) % 4;\r\n        if (i % 2 === 0)\r\n            bridge = new ColorTile(\"pink\");\r\n        center1.getReference(i).to.link(reverse, bridge);\r\n        center2.getReference(reverse).to.link(i, bridge);\r\n    }\r\n    return grid1.get(4, 7);\r\n}\r\nexport function branches(n = 7) {\r\n    if (n === 0) {\r\n        return new ColorTile(\"red\");\r\n    }\r\n    const color = `hsl(${Math.random() * 360},50%,50%)`;\r\n    const out = new ColorTile(color);\r\n    function addSide(side) {\r\n        const bridge = new ColorTile(color);\r\n        out.link(side, bridge, 1 /* bottom */);\r\n        bridge.link(3 /* top */, branches(n - 1), 1 /* bottom */);\r\n    }\r\n    addSide(3 /* top */);\r\n    addSide(1 /* bottom */);\r\n    addSide(2 /* left */);\r\n    addSide(0 /* right */);\r\n    return out;\r\n}\r\nexport function branches2() {\r\n    const S = 4;\r\n    function inner(n = 7) {\r\n        const color = `hsl(${Math.random() * 360},50%,50%)`;\r\n        if (n === 0) {\r\n            return new TileGrid(S, S, [\r\n                solidColorTiles(color)\r\n            ]);\r\n        }\r\n        const out = new TileGrid(S, S, [\r\n            solidColorTiles(color)\r\n        ]);\r\n        const north = inner(n - 1);\r\n        const east = inner(n - 1);\r\n        const west = inner(n - 1);\r\n        for (let i = 0; i < S; i++) {\r\n            out.get(i, 0).link(3 /* top */, north.get(i, S - 1));\r\n            out.get(0, S - 1 - i).link(2 /* left */, east.get(i, S - 1), 1 /* bottom */);\r\n            out.get(S - 1, i).link(0 /* right */, west.get(i, S - 1), 1 /* bottom */);\r\n        }\r\n        return out;\r\n    }\r\n    return inner().get(Math.floor(S / 2), S - 1);\r\n}\r\nexport function mirror() {\r\n    const grid = new TileGrid(5, 5, [\r\n        dynamicColor(5, 5)\r\n    ]);\r\n    for (let i = 1; i < 4; i++) {\r\n        grid.get(2, i).link(0 /* right */, grid.get(2, i), 0 /* right */, {\r\n            reflect: true\r\n        });\r\n    }\r\n    return grid.get(0, 4);\r\n}\r\nexport function tickTackToeBasic() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer()\r\n    ]);\r\n    return grid.get(0, 2);\r\n}\r\nexport function tickTackToeDonut() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer()\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i));\r\n        grid.get(i, 0).link(3 /* top */, grid.get(i, 2));\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeDonutOffset() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(4)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i));\r\n        grid.get((i + 1) % 3, 0).link(3 /* top */, grid.get(i, 2));\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeKlign() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(4)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(2, i), 0 /* right */, { reflect: false });\r\n        grid.get(i, 0).link(3 /* top */, grid.get(2 - i, 2), 1 /* bottom */, { reflect: true });\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function tickTackToeMirror() {\r\n    const grid = new TileGrid(3, 3, [\r\n        tickTackToeLayer(5)\r\n    ]);\r\n    const bridge = new ColorTile(\"white\");\r\n    for (let i = 0; i < 3; i++) {\r\n        grid.get(0, i).link(2 /* left */, grid.get(0, i), 2 /* left */, { reflect: true, addReverse: false });\r\n        grid.get(2, i).link(0 /* right */, grid.get(2, i), 0 /* right */, { reflect: true, addReverse: false });\r\n        grid.get(i, 2).link(1 /* bottom */, grid.get(i, 2), 1 /* bottom */, { reflect: true, addReverse: false });\r\n        grid.get(i, 0).link(3 /* top */, grid.get(i, 0), 3 /* top */, { reflect: true, addReverse: false });\r\n    }\r\n    bridge.link(3 /* top */, grid.get(0, 2), 1 /* bottom */, {\r\n        addReverse: false\r\n    });\r\n    return bridge;\r\n}\r\nexport function mobius(W = 5, H = 5) {\r\n    const grid = new TileGrid(W, H, [\r\n        dynamicColor(W, H)\r\n    ]);\r\n    for (let i = 0; i < H; i++) {\r\n        grid.get(W - 1, i).link(0 /* right */, grid.get(0, H - i - 1), 2 /* left */, {\r\n            reflect: true\r\n        });\r\n    }\r\n    return grid.get(0, H - 1);\r\n}\r\nexport function spiral(S = 10) {\r\n    let len = S - 2;\r\n    let dir = 0 /* right */;\r\n    const grid = new TileGrid(S, S, [\r\n        dynamicColor(S, S)\r\n    ]);\r\n    let tile = grid.get(0, S - 1);\r\n    while (len > 2) {\r\n        len -= 1 / 2;\r\n        for (let i = 0; i < len; i++) {\r\n            tile = tile.links[dir].to;\r\n        }\r\n        const ot = tile;\r\n        const nextDir = (dir - 1) & 0b11;\r\n        const mid = tile.links[dir].to;\r\n        tile = mid.links[nextDir].to;\r\n        mid.isolate();\r\n        ot.link(dir, tile, (nextDir + 2) & 3);\r\n        dir = nextDir;\r\n    }\r\n    return grid.get(0, S - 1);\r\n}\r\nexport function wheel(S = 5) {\r\n    const center = new TileGrid(S, S, [\r\n        dynamicColor(S, S)\r\n    ]);\r\n    const root = center.get(0, 0);\r\n    const edgeLength = S + 1;\r\n    const edge = new TileGrid(edgeLength * 4, 1, [\r\n        rain(edgeLength * 4, 0)\r\n    ]);\r\n    edge.get(0, 0).link(2 /* left */, edge.get(edgeLength * 4 - 1, 0));\r\n    let dest = root.getView(1 /* bottom */);\r\n    for (let i = 0; i < edgeLength * 4; i++) {\r\n        if (i % edgeLength === 1)\r\n            continue;\r\n        edge.get(i, 0).getView(0).link(1 /* bottom */, dest, 3 /* top */);\r\n        if (i % edgeLength === 0) {\r\n            dest = dest.rotate(3 /* top */);\r\n        }\r\n        else {\r\n            dest = dest.getNeighbor(0 /* right */);\r\n        }\r\n    }\r\n    return center.get(S / 2 | 0, S / 2 | 0);\r\n}\r\nexport function makeHubRoom(worlds, color = 'gold') {\r\n    const root = [new ColorTile('red'), new ColorTile('pink')];\r\n    for (let i = 0; i < worlds.length - 1; i++) {\r\n        const left = worlds[i];\r\n        const right = worlds[(i + 1)];\r\n        if (left instanceof Array && right instanceof Array) {\r\n            left[1].forEach((e, i) => {\r\n                e.link(0 /* right */, right[0][i]);\r\n            });\r\n        }\r\n    }\r\n    const out = worlds.reduceRight(([rightTile, rightBridge], worldRoot) => {\r\n        const hubTile = new ColorTile(color);\r\n        const hubBridge = new ColorTile(color);\r\n        const leftBridge = new ColorTile(color);\r\n        const leftTile = new ColorTile(color);\r\n        hubTile.link(0 /* right */, rightTile);\r\n        hubBridge.link(0 /* right */, rightBridge);\r\n        leftTile.link(0 /* right */, hubTile);\r\n        leftBridge.link(0 /* right */, hubBridge);\r\n        hubBridge.link(1 /* bottom */, hubTile);\r\n        if (worldRoot !== false)\r\n            hubBridge.link(3 /* top */, worldRoot instanceof Array ? worldRoot[1][0] : worldRoot);\r\n        if (worldRoot instanceof Array)\r\n            leftBridge.link(3 /* top */, worldRoot[0][0]);\r\n        hubTile.link(3 /* top */, hubBridge);\r\n        leftBridge.link(1 /* bottom */, leftTile);\r\n        return (worldRoot instanceof Array) ? [leftTile, leftBridge] : [hubTile, hubBridge];\r\n    }, root);\r\n    console.log(root);\r\n    const base = root.map(e => e.links[2 /* left */].to);\r\n    root.map(e => e.isolate());\r\n    return [out, base];\r\n}\r\nexport function hubRoom() {\r\n    const data = makeHubRoom([\r\n        makeHubRoom([\r\n            portSpace(),\r\n            ballPort(),\r\n            mirror(),\r\n            bridge()\r\n        ], 'pink'),\r\n        makeHubRoom([\r\n            shortWay(),\r\n            fastLane(),\r\n            fastLane2(),\r\n            threeTurns()\r\n        ], 'cyan'),\r\n        makeHubRoom([\r\n            branches(),\r\n            branches2(),\r\n        ], 'red'),\r\n        makeHubRoom([\r\n            tickTackToeBasic(),\r\n            tickTackToeDonut(),\r\n            tickTackToeKlign(),\r\n            tickTackToeMirror(),\r\n            tickTackToeDonutOffset()\r\n        ], 'grey'),\r\n        makeHubRoom([\r\n            mobius(),\r\n            mobius(30),\r\n            spiral(),\r\n            wheel()\r\n        ], 'blue')\r\n    ]);\r\n    autoWall(data[0][1]);\r\n    return data[0][1];\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/testLevels.ts\n// module id = 13\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nexport class TileGrid {\r\n    constructor(width, height, layers = []) {\r\n        const getTiles = layers.reduce((a, b) => (next) => a(b(next)), (x) => x)((x, y) => new Tile());\r\n        this.tiles = [...Array(height)].map((_, y) => [...Array(width)].map((_, x) => getTiles(x, y)));\r\n        this.tiles.forEach((row, y) => {\r\n            row.forEach((tile, x) => {\r\n                if (!tile)\r\n                    return;\r\n                if (y !== 0 && this.tiles[y - 1][x]) {\r\n                    this.tiles[y - 1][x].link(1 /* bottom */, tile);\r\n                }\r\n                if (x !== 0 && row[x - 1]) {\r\n                    row[x - 1].link(0 /* right */, tile);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    get(x, y) {\r\n        return this.tiles[y][x];\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TileGrid.ts\n// module id = 14\n// module chunks = 0","import { makeDirMtx, dirMtxProduct } from \"./DirMtx\";\r\nimport { reverseSide } from \"./Side\";\r\nexport class SideReference {\r\n    constructor(to, mtx, destSide) {\r\n        this.to = to;\r\n        this.mtx = mtx;\r\n        this.destSide = destSide;\r\n    }\r\n    static fromOpts(toTile, fromSide, destSide, reflect) {\r\n        return new SideReference(toTile, dirMtxProduct(makeDirMtx(-reverseSide(destSide), reflect), fromSide), destSide);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SideReference.ts\n// module id = 15\n// module chunks = 0","import { dirMtxApply, dirMtxInverse, dirMtxProductImpl } from \"./DirMtx\";\r\nimport { reverseSide } from \"./Side\";\r\nconst lookupMaps = [...Array(8)].map((i) => {\r\n    return new WeakMap();\r\n});\r\nexport class TileView {\r\n    static lookup(tile, orientation) {\r\n        return tile.tileViews[orientation];\r\n        // const map = lookupMaps[orientation];\r\n        // if(!map.has(tile)){\r\n        //     const view = new TileView(tile, orientation);\r\n        //     map.set(tile, view);\r\n        //     return view;\r\n        // }\r\n        // return map.get(tile);\r\n    }\r\n    constructor(tile, orientation) {\r\n        this.tile = tile;\r\n        this.orientation = orientation;\r\n        this.id = `${tile.id},${orientation}`;\r\n    }\r\n    computeSide(i) {\r\n        return dirMtxApply(dirMtxInverse(this.orientation), i);\r\n    }\r\n    getNeighbor(i) {\r\n        const edge = this.tile.getReference(this.computeSide(i));\r\n        if (edge) {\r\n            return TileView.lookup(edge.to, dirMtxProductImpl(this.orientation, edge.mtx));\r\n        }\r\n        return null;\r\n    }\r\n    stepOn(t) {\r\n        this.tile.stepOn(t);\r\n    }\r\n    interact(t) {\r\n        this.tile.interact(t);\r\n    }\r\n    track(entity) {\r\n        this.tile.track(entity);\r\n    }\r\n    link(fromSide, toTile, toSide = reverseSide(fromSide), { reflect = false, addReverse = true } = {}) {\r\n        this.tile.link(this.computeSide(fromSide), toTile.tile, toTile.computeSide(toSide), {\r\n            reflect: !reflect !== !((toTile.orientation ^ this.orientation) & 0b100),\r\n            addReverse\r\n        });\r\n    }\r\n    rotate(mtx) {\r\n        return this.tile.getView(dirMtxProductImpl(mtx, this.orientation));\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TileView.ts\n// module id = 16\n// module chunks = 0","import { ColorTile } from \"../ColorTile\";\r\nimport { TILE_SIZE } from \"../opts\";\r\nimport { strictCompose } from \"../compose\";\r\nvar Turn;\r\n(function (Turn) {\r\n    Turn[Turn[\"RED\"] = -1] = \"RED\";\r\n    Turn[Turn[\"NONE\"] = 0] = \"NONE\";\r\n    Turn[Turn[\"BLACK\"] = 1] = \"BLACK\";\r\n})(Turn || (Turn = {}));\r\nfunction turnColor(turn) {\r\n    return turn === Turn.RED ? \"RED\" : turn === Turn.BLACK ? \"black\" : \"grey\";\r\n}\r\nclass TickTackToeGame {\r\n    constructor() {\r\n        this.turn = Turn.RED;\r\n        this.won = Turn.NONE;\r\n        this.blankTiles = 0;\r\n    }\r\n}\r\nconst MARGIN = TILE_SIZE / 6;\r\nfunction singleStepMovement(dir) {\r\n    return (t) => {\r\n        if (!t)\r\n            return null;\r\n        return t.getNeighbor(dir);\r\n    };\r\n}\r\nfunction movement(dirs) {\r\n    return strictCompose(dirs.map(singleStepMovement));\r\n}\r\nconst movementMethods = [\r\n    [3 /* top */, 1 /* bottom */].map(singleStepMovement),\r\n    [2 /* left */, 0 /* right */].map(singleStepMovement),\r\n    [\r\n        [2 /* left */, 1 /* bottom */],\r\n        [3 /* top */, 0 /* right */]\r\n    ].map(movement),\r\n    [\r\n        [1 /* bottom */, 2 /* left */],\r\n        [0 /* right */, 3 /* top */]\r\n    ].map(movement),\r\n    [\r\n        [2 /* left */, 3 /* top */],\r\n        [1 /* bottom */, 0 /* right */]\r\n    ].map(movement),\r\n    [\r\n        [3 /* top */, 2 /* left */],\r\n        [0 /* right */, 1 /* bottom */]\r\n    ].map(movement)\r\n];\r\nexport class TickTackToeTile extends ColorTile {\r\n    constructor(lengthForWin = 3) {\r\n        super(\"white\");\r\n        this.occupied = Turn.NONE;\r\n        this.game = null;\r\n        this.isWinningLine = false;\r\n        this.lengthForWin = lengthForWin;\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        super.render(ctx, t, playerDist, playerShear);\r\n        ctx.fillStyle = turnColor(this.occupied);\r\n        const margin = this.game && ((this.game.won !== Turn.NONE || this.game.blankTiles === 0) && !this.isWinningLine) ? MARGIN * 2 : MARGIN;\r\n        ctx.fillRect(margin, margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);\r\n        if (this.game && t - this.stepTime < 100) {\r\n            ctx.strokeStyle = turnColor(this.game.turn);\r\n            ctx.lineWidth = 5;\r\n            ctx.strokeRect(margin, margin, TILE_SIZE - margin * 2, TILE_SIZE - margin * 2);\r\n        }\r\n    }\r\n    tallyInDir(movmentPattern) {\r\n        let view = this.getView(0);\r\n        for (let i = 0; i < this.lengthForWin; i++) {\r\n            view = movmentPattern(view);\r\n            if (!view || !(view.tile instanceof TickTackToeTile && view.tile.occupied === this.occupied)) {\r\n                return i;\r\n            }\r\n        }\r\n        return this.lengthForWin;\r\n    }\r\n    drawWinningLine(movmentPattern) {\r\n        let view = this.getView(0);\r\n        for (let i = 0; i < this.lengthForWin; i++) {\r\n            view = movmentPattern(view);\r\n            if (!view || !(view.tile instanceof TickTackToeTile && view.tile.occupied === this.occupied)) {\r\n                return;\r\n            }\r\n            view.tile.isWinningLine = true;\r\n        }\r\n    }\r\n    didWin() {\r\n        for (let pair of movementMethods) {\r\n            const n = this.tallyInDir(pair[0]) + this.tallyInDir(pair[1]) + 1;\r\n            if (n >= this.lengthForWin) {\r\n                this.drawWinningLine(pair[0]);\r\n                this.drawWinningLine(pair[1]);\r\n                this.isWinningLine = true;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    linkGame(game = new TickTackToeGame()) {\r\n        if (this.game !== game) {\r\n            this.occupied = Turn.NONE;\r\n            this.isWinningLine = false;\r\n            this.game = game;\r\n            game.blankTiles++;\r\n            this.links.forEach((link) => {\r\n                if (!link)\r\n                    return;\r\n                const tile = link.to;\r\n                if (tile instanceof TickTackToeTile) {\r\n                    tile.linkGame(game);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    stepOn(t) {\r\n        super.stepOn(t);\r\n        if (this.game === null) {\r\n            this.linkGame();\r\n        }\r\n    }\r\n    interact() {\r\n        if (this.game === null || this.game.won !== Turn.NONE || this.game.blankTiles === 0) {\r\n            this.linkGame();\r\n            return;\r\n        }\r\n        if (this.occupied === Turn.NONE) {\r\n            this.occupied = this.game.turn;\r\n            this.game.turn = -this.game.turn;\r\n            this.game.blankTiles--;\r\n            if (this.didWin()) {\r\n                this.game.won = this.occupied;\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tickTackToe/TickTackToeTile.ts\n// module id = 17\n// module chunks = 0","import { WallTile } from \"./WallTile\";\r\nexport function autoWall(root) {\r\n    console.time(\"wall\");\r\n    const explored = new Set();\r\n    const wallsToLink = new Set();\r\n    let maxExplore = 1000;\r\n    explored.add(root);\r\n    console.time(\"wallExplore\");\r\n    for (let tile of explored) {\r\n        for (let i = 0; i < 4; i++) {\r\n            const edge = tile.getReference(i);\r\n            if (edge) {\r\n                const nextTile = edge.to;\r\n                if (nextTile instanceof WallTile || explored.has(nextTile)) {\r\n                    continue;\r\n                }\r\n                explored.add(nextTile);\r\n            }\r\n            else {\r\n                const nt = new WallTile();\r\n                wallsToLink.add(nt);\r\n                nt.link(2 /* left */, tile, i);\r\n            }\r\n        }\r\n    }\r\n    console.timeEnd(\"wallExplore\");\r\n    console.time(\"wallLink\");\r\n    for (let wall of wallsToLink) {\r\n        const base = wall.getView(0).getNeighbor(2 /* left */);\r\n        if (!base)\r\n            continue;\r\n        for (let dir of [3 /* top */, 1 /* bottom */]) {\r\n            if (wall.getReference(dir))\r\n                continue;\r\n            const nextBase = base.getNeighbor(dir);\r\n            if (nextBase.tile instanceof WallTile)\r\n                continue;\r\n            const targWall = nextBase.getNeighbor(0 /* right */);\r\n            if (!(targWall.tile instanceof WallTile))\r\n                continue;\r\n            wall.getView(0).link(dir, targWall);\r\n        }\r\n    }\r\n    console.timeEnd(\"wallLink\");\r\n    for (let wall of wallsToLink) {\r\n        const wallShade = wall.wallShade;\r\n        for (let dir of [3 /* top */, 1 /* bottom */]) {\r\n            let view = wall.getView(0).getNeighbor(dir);\r\n            while (view && view.tile instanceof WallTile && view.tile !== wall) {\r\n                wallsToLink.delete(view.tile);\r\n                view.tile.wallShade = wallShade;\r\n                view = view.getNeighbor(dir);\r\n            }\r\n        }\r\n    }\r\n    console.timeEnd(\"wall\");\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/autoWall.ts\n// module id = 18\n// module chunks = 0","import { Tile } from \"./Tile\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst PERSPECTIVE = 1 / 5;\r\nexport class WallTile extends Tile {\r\n    constructor(height = 1) {\r\n        super();\r\n        this.walkable = false;\r\n        this.height = height;\r\n        this.wallShade = 1 - 0.5 * Math.random();\r\n    }\r\n    render(ctx, t, playerDist, playerShear) {\r\n        super.render(ctx, t, playerDist, playerShear);\r\n        if (playerDist > 0) {\r\n            ctx.globalAlpha = this.wallShade;\r\n            ctx.fillStyle = \"grey\";\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, 0);\r\n            ctx.lineTo(playerDist * PERSPECTIVE * this.height, playerShear * PERSPECTIVE * this.height);\r\n            ctx.lineTo(playerDist * PERSPECTIVE * this.height, (playerShear + TILE_SIZE) * PERSPECTIVE * this.height + TILE_SIZE);\r\n            ctx.lineTo(0, TILE_SIZE);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/WallTile.ts\n// module id = 19\n// module chunks = 0","import { RenderableEntity } from \"./RenderableEntity\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nimport { Bolt } from \"./Bolt\";\r\nconst PLAYER_SIZE = 1 / 3;\r\nconst onScreenSize = TILE_SIZE * PLAYER_SIZE;\r\nexport class Player extends RenderableEntity {\r\n    constructor(spawnPt, app) {\r\n        super(PLAYER_SIZE, PLAYER_SIZE, spawnPt);\r\n        this.app = app;\r\n    }\r\n    render(ctx) {\r\n        ctx.fillStyle = \"black\";\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(0, 0, onScreenSize / 2, onScreenSize / 2);\r\n        ctx.fillRect(0, 0, onScreenSize / 2, onScreenSize / 2);\r\n        ctx.strokeRect(0, onScreenSize / 2, onScreenSize, onScreenSize / 2);\r\n        ctx.fillRect(0, onScreenSize / 2, onScreenSize, onScreenSize / 2);\r\n    }\r\n    shoot(dir = this.lastMovementDir) {\r\n        const bolt = new Bolt(dir, this.center.view);\r\n        bolt.move(this.center.pt.x - bolt.center.pt.x, this.center.pt.y - bolt.center.pt.y);\r\n        this.app.addStepable(bolt);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Player.ts\n// module id = 20\n// module chunks = 0","import { ViewCursor } from \"./ViewCursor\";\r\nexport class Entity {\r\n    constructor(width, height, baseTile) {\r\n        this.trackWidth = 2;\r\n        this.trackHeight = 2;\r\n        this.init(width, height, baseTile);\r\n    }\r\n    respawn(view) {\r\n        this.init(this.width, this.height, view);\r\n    }\r\n    init(width, height, baseTile) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if (width > 1 || height > 1)\r\n            throw new RangeError(\"we do not yet suport entities larger than one tile\");\r\n        this.trackingTiles = Array(this.trackWidth);\r\n        this.trackingTilesOld = Array(this.trackWidth);\r\n        for (let x = 0; x < this.trackWidth; x++) {\r\n            this.trackingTiles[x] = Array(this.trackHeight);\r\n            this.trackingTilesOld[x] = Array(this.trackHeight);\r\n            for (let y = 0; y < this.trackHeight; y++) {\r\n                const trackingPointX = width / (this.trackWidth - 1) * x, trackingPointY = height / (this.trackHeight - 1) * y;\r\n                const tracker = new ViewCursor(baseTile, 0.5 - (width / 2) + trackingPointX, 0.5 - (height / 2) + trackingPointY, trackingPointX, trackingPointY);\r\n                this.trackingTiles[x][y] = tracker;\r\n                this.trackingTilesOld[x][y] = tracker.clone();\r\n            }\r\n        }\r\n        this.center = new ViewCursor(baseTile, 0.5, 0.5, width / 2, height / 2);\r\n        this.centerOld = this.center.clone();\r\n    }\r\n    move(dx, dy) {\r\n        let xSide = dx < 0 ? 2 /* left */ : 0 /* right */;\r\n        let ySide = dy < 0 ? 3 /* top */ : 1 /* bottom */;\r\n        let xLeft = Math.abs(dx);\r\n        let yLeft = Math.abs(dy);\r\n        let xLocked = xLeft === 0;\r\n        let yLocked = yLeft === 0;\r\n        let i = 0;\r\n        this.lastMovementDir = xLeft >= yLeft ? xSide : ySide;\r\n        while ((xLeft > 0 || yLeft > 0) && i < 100) {\r\n            i++;\r\n            if (!xLocked && xLeft > 0) {\r\n                let oPosn = xLeft;\r\n                xLeft = this.tryMove(xSide, xLeft);\r\n                yLocked = yLocked && (oPosn === xLeft || yLeft <= 0);\r\n                xLocked = true;\r\n            }\r\n            if (yLocked)\r\n                break;\r\n            if (!yLocked && yLeft > 0) {\r\n                let oPosn = yLeft;\r\n                yLeft = this.tryMove(ySide, yLeft);\r\n                xLocked = xLocked && (oPosn === yLeft || xLeft <= 0);\r\n                yLocked = true;\r\n            }\r\n            if (xLocked)\r\n                break;\r\n        }\r\n        return xLeft === 0 && yLeft === 0;\r\n    }\r\n    tryMove(side, dist) {\r\n        let distLeft = dist;\r\n        let i = 0;\r\n        while (distLeft > 0 && i < 100) {\r\n            i++;\r\n            //move to edge of tile\r\n            let maxMovement = distLeft;\r\n            for (let x = 0; x < this.trackWidth; x++) {\r\n                for (let y = 0; y < this.trackWidth; y++) {\r\n                    const newDist = this.trackingTiles[x][y].movementUpToEdge(side);\r\n                    if (newDist < maxMovement)\r\n                        maxMovement = newDist;\r\n                }\r\n            }\r\n            const newDist = this.center.movementUpToEdge(side);\r\n            if (newDist < maxMovement)\r\n                maxMovement = newDist;\r\n            if (maxMovement > 0) {\r\n                for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        this.trackingTiles[x][y].moveWithinTile(side, maxMovement);\r\n                    }\r\n                }\r\n                this.center.moveWithinTile(side, maxMovement);\r\n            }\r\n            if (maxMovement === distLeft) {\r\n                distLeft = 0;\r\n                break;\r\n            }\r\n            distLeft -= maxMovement;\r\n            //cross edge\r\n            let crossingValid = true;\r\n            for (let x = 0; x < this.trackWidth; x++) {\r\n                for (let y = 0; y < this.trackWidth; y++) {\r\n                    const thisTracker = this.trackingTiles[x][y];\r\n                    this.trackingTilesOld[x][y].copy(thisTracker);\r\n                    crossingValid = crossingValid && thisTracker.tryCrossEdge(side) && thisTracker.view.tile.walkable;\r\n                }\r\n            }\r\n            this.centerOld.copy(this.center);\r\n            crossingValid = crossingValid && this.center.tryCrossEdge(side) && this.center.view.tile.walkable;\r\n            if (crossingValid) {\r\n                outer: for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        const tgtView = this.trackingTiles[x][y].view;\r\n                        if (x !== 0) {\r\n                            const leftView = this.trackingTiles[x - 1][y].view;\r\n                            crossingValid = crossingValid && (tgtView === leftView || tgtView.getNeighbor(2 /* left */) === leftView);\r\n                        }\r\n                        if (y !== 0) {\r\n                            const topView = this.trackingTiles[x][y - 1].view;\r\n                            crossingValid = crossingValid && (tgtView === topView || tgtView.getNeighbor(3 /* top */) === topView);\r\n                        }\r\n                        if (!crossingValid) {\r\n                            break outer;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!crossingValid) {\r\n                for (let x = 0; x < this.trackWidth; x++) {\r\n                    for (let y = 0; y < this.trackWidth; y++) {\r\n                        this.trackingTiles[x][y].copy(this.trackingTilesOld[x][y]);\r\n                    }\r\n                }\r\n                this.center.copy(this.centerOld);\r\n                break;\r\n            }\r\n        }\r\n        return distLeft;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Entity.ts\n// module id = 21\n// module chunks = 0","import { Cursor } from \"./Cursor\";\r\nexport class ViewCursor {\r\n    constructor(view, x, y, onEntityX, onEntityY) {\r\n        this.view = view;\r\n        this.pt = new Cursor({ x, y });\r\n        this.onEntityX = onEntityX;\r\n        this.onEntityY = onEntityY;\r\n    }\r\n    movementUpToEdge(dir) {\r\n        switch (dir) {\r\n            case 2 /* left */: return this.pt.x;\r\n            case 0 /* right */: return 1 - this.pt.x;\r\n            case 3 /* top */: return this.pt.y;\r\n            case 1 /* bottom */: return 1 - this.pt.y;\r\n        }\r\n    }\r\n    moveWithinTile(dir, dist) {\r\n        this.pt.step(dir, dist);\r\n    }\r\n    tryCrossEdge(dir) {\r\n        if (this.movementUpToEdge(dir) === 0) {\r\n            const next = this.view.getNeighbor(dir);\r\n            if (!next)\r\n                return false;\r\n            this.pt.step(dir, -1);\r\n            this.view = next;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    copy(other) {\r\n        this.pt = other.pt.fork();\r\n        this.view = other.view;\r\n        this.onEntityY = other.onEntityY;\r\n        this.onEntityX = other.onEntityX;\r\n    }\r\n    clone() {\r\n        return new ViewCursor(this.view, this.pt.x, this.pt.y, this.onEntityX, this.onEntityY);\r\n    }\r\n    move(dx, dy) {\r\n        let xSide = dx < 0 ? 2 /* left */ : 0 /* right */;\r\n        let ySide = dy < 0 ? 3 /* top */ : 1 /* bottom */;\r\n        let xLeft = Math.abs(dx);\r\n        let yLeft = Math.abs(dy);\r\n        let xLocked = xLeft === 0;\r\n        let yLocked = yLeft === 0;\r\n        let i = 0;\r\n        while ((xLeft > 0 || yLeft > 0) && i < 100) {\r\n            i++;\r\n            if (!xLocked && xLeft > 0) {\r\n                let oPosn = xLeft;\r\n                xLeft = this.tryMove(xSide, xLeft);\r\n                yLocked = yLocked && (oPosn === xLeft || yLeft <= 0);\r\n                xLocked = true;\r\n            }\r\n            if (yLocked)\r\n                break;\r\n            if (!yLocked && yLeft > 0) {\r\n                let oPosn = yLeft;\r\n                yLeft = this.tryMove(ySide, yLeft);\r\n                xLocked = xLocked && (oPosn === yLeft || xLeft <= 0);\r\n                yLocked = true;\r\n            }\r\n            if (xLocked)\r\n                break;\r\n        }\r\n        if (xLeft !== 0 && yLeft !== 0)\r\n            console.log(xLeft, yLeft);\r\n        return xLeft === 0 && yLeft === 0;\r\n    }\r\n    tryMove(dir, dist) {\r\n        let i = 0;\r\n        let left = dist;\r\n        while (left > 0 && i < 100) {\r\n            i--;\r\n            const canMove = Math.min(this.movementUpToEdge(dir), left);\r\n            if (canMove > 0) {\r\n                this.moveWithinTile(dir, canMove);\r\n            }\r\n            left -= canMove;\r\n            if (left === canMove)\r\n                break;\r\n            if (!this.tryCrossEdge(dir))\r\n                break;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ViewCursor.ts\n// module id = 22\n// module chunks = 0","import { RenderableEntity } from \"./RenderableEntity\";\r\nimport { getDelta } from \"./Side\";\r\nimport { TILE_SIZE } from \"./opts\";\r\nconst BOLT_SPEED = 10 / 1000;\r\nexport class Bolt extends RenderableEntity {\r\n    constructor(dir, tile) {\r\n        super(dir & 1 ? 1 / 6 : 5 / 6, dir & 1 ? 5 / 6 : 1 / 6, tile);\r\n        this.age = 0;\r\n        this.dir = dir;\r\n        this.dirPt = getDelta(dir);\r\n    }\r\n    step(dt) {\r\n        this.age += dt;\r\n        const hitWall = !this.move(this.dirPt.x * BOLT_SPEED * dt, this.dirPt.y * BOLT_SPEED * dt);\r\n        if (hitWall) {\r\n            this.age += dt * 10;\r\n        }\r\n        const stayAlive = this.age < 10000;\r\n        if (!stayAlive)\r\n            this.kill();\r\n        return stayAlive;\r\n    }\r\n    render(ctx) {\r\n        ctx.lineWidth = 2;\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(0, 0, this.width * TILE_SIZE, this.height * TILE_SIZE);\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.strokeRect(0, 0, this.width * TILE_SIZE, this.height * TILE_SIZE);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Bolt.ts\n// module id = 23\n// module chunks = 0"],"sourceRoot":""}